# üì¶ M√≥dulos est√°ndar de Python
import os
import time
import threading
import random
import re
from datetime import datetime, timedelta
from collections import Counter
from typing import List, Optional  # ‚úÖ Agregado para evitar NameError

# üß™ Librer√≠as externas
import psycopg2
from psycopg2 import sql
import numpy as np
import openai
from pydantic import BaseModel

# üöÄ Framework FastAPI
from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, HTMLResponse

# üß† Diccionario de sesiones por usuario (en memoria)
user_sessions = {}

from cerebro_simulado import (
    predecir_evento_futuro,
    inferir_patron_interactivo,
    evaluar_coherencia_mensaje,
    clasificar_estado_mental,
    inferir_intencion_usuario
)

# ========================== CONSTANTES DE CLASIFICACI√ìN ==========================

CLINICO_CONTINUACION = "CLINICO_CONTINUACION"
SALUDO = "SALUDO"
CORTESIA = "CORTESIA"
ADMINISTRATIVO = "ADMINISTRATIVO"
CLINICO = "CLINICO"
CONSULTA_AGENDAR = "CONSULTA_AGENDAR"
CONSULTA_MODALIDAD = "CONSULTA_MODALIDAD"

def es_consulta_contacto(mensaje: str, user_id: str = None, mensaje_original: str = None) -> bool:
    """
    Detecta si el mensaje hace referencia al deseo de contactar al profesional.
    Si hay coincidencia y se proporciona `user_id` y `mensaje_original`, registra la auditor√≠a autom√°ticamente.
    """
    if not mensaje or not isinstance(mensaje, str):
        return False

    mensaje = mensaje.lower()

    expresiones_contacto = [
        "contacto", "numero", "n√∫mero", "whatsapp", "tel√©fono", "telefono",
        "como lo contacto", "quiero contactarlo", "como me comunico",
        "quiero escribirle", "quiero hablar con √©l", "me das el n√∫mero",
        "como se agenda", "como saco turno", "quiero pedir turno",
        "necesito contactarlo", "como empiezo la terapia", "quiero empezar la consulta",
        "como me comunico con el licenciado", "mejor psicologo", "mejor terapeuta",
        "atienden estos casos", "atiende casos", "trata casos", "atiende temas",
        "trata temas", "atiende estos", "trata estos", "atiende estos temas"
    ]

    hay_coincidencia = any(exp in mensaje for exp in expresiones_contacto)

    if hay_coincidencia and user_id and mensaje_original:
        registrar_auditoria_input_original(user_id, mensaje_original, mensaje, "CONSULTA_CONTACTO")

    return hay_coincidencia

# ‚úÖ Funci√≥n reutilizable de seguridad textual
def contiene_elementos_peligrosos(texto: str) -> bool:
    """
    Detecta si un texto contiene patrones potencialmente peligrosos o maliciosos
    como comandos de sistema, c√≥digo fuente o expresiones t√©cnicas sensibles.
    """
    patrones_riesgosos = [
        r"openai\.api_key", r"import\s", r"os\.system", r"eval\(", r"exec\(",
        r"<script", r"</script>", r"\bdrop\b.*\btable\b", r"\bdelete\b.*\bfrom\b",
        r"\brm\s+-rf\b", r"\bchmod\b", r"\bmkfs\b", r"\bshutdown\b", r"\breboot\b",
        r"SELECT\s+.*\s+FROM", r"INSERT\s+INTO", r"UPDATE\s+\w+\s+SET", r"DELETE\s+FROM"
    ]
    return any(re.search(patron, texto, re.IGNORECASE) for patron in patrones_riesgosos)

# üìû Funci√≥n centralizada para mensaje de contacto
def obtener_mensaje_contacto():
    return (
        "En caso de que desees contactar al Lic. Daniel O. Bustamante, "
        "pod√©s hacerlo escribi√©ndole al WhatsApp +54 911 3310-1186, que con gusto responder√° a tus inquietudes."
    )


# üß† Lista de preguntas frecuentes (FAQ) y sus respuestas fijas
faq_respuestas = [
    {
        "pregunta": "¬øQu√© servicios ofrece?",
        "respuesta": (
            "El Lic. Daniel O. Bustamante brinda atenci√≥n psicol√≥gica exclusivamente online, a trav√©s de videoconsultas.\n\n"
            "Entre los principales motivos de consulta que aborda se encuentran:\n"
            "- Psicoterapia individual para adultos (modalidad online)\n"
            "- Tratamiento de crisis emocionales\n"
            "- Abordaje de ansiedad, estr√©s y ataques de p√°nico\n"
            "- Procesos de duelo y cambios vitales\n"
            "- Estados an√≠micos depresivos\n"
            "- Problemas de autoestima y motivaci√≥n\n"
            "- Dificultades vinculares y emocionales\n"
            "- Terapia de pareja online\n\n"
            + obtener_mensaje_contacto()
        )
    },
    {
        "pregunta": "¬øCu√°nto dura la sesi√≥n?",
        "respuesta": (
            "Las sesiones con el Lic. Daniel O. Bustamante tienen una duraci√≥n aproximada de 50 minutos y se realizan por videoconsulta.\n\n"
            "La frecuencia puede variar seg√∫n cada caso, pero generalmente se recomienda un encuentro semanal para favorecer el proceso terap√©utico.\n\n"
            + obtener_mensaje_contacto()
        )
    },
    {
        "pregunta": "¬øTrabaja con obras sociales?",
        "respuesta": (
            "El Lic. Daniel O. Bustamante no trabaja con obras sociales ni prepagas. Atiende √∫nicamente de manera particular. "
            + obtener_mensaje_contacto()
        )
    }
]


# ‚ö° Generar embeddings de las preguntas frecuentes (una sola vez al iniciar la app)
def generar_embeddings_faq():
    preguntas = [item["pregunta"] for item in faq_respuestas]
    response = openai.Embedding.create(
        model="text-embedding-ada-002",
        input=preguntas
    )
    for i, embedding in enumerate(response["data"]):
        faq_respuestas[i]["embedding"] = np.array(embedding["embedding"])

from numpy.linalg import norm

def buscar_respuesta_semantica(mensaje: str, umbral=0.88) -> str | None:
    try:
        # Embedding del mensaje del usuario
        embedding_usuario = openai.Embedding.create(
            model="text-embedding-ada-002",
            input=mensaje
        )["data"][0]["embedding"]
        embedding_usuario = np.array(embedding_usuario)

        # Calcular similitud con cada pregunta frecuente
        mejor_score = 0
        mejor_respuesta = None
        for item in faq_respuestas:
            emb_faq = item.get("embedding")
            if emb_faq is not None:
                similitud = np.dot(embedding_usuario, emb_faq) / (norm(embedding_usuario) * norm(emb_faq))
                if similitud > mejor_score and similitud >= umbral:
                    mejor_score = similitud
                    mejor_respuesta = item["respuesta"]

        return mejor_respuesta

    except Exception as e:
        print(f"‚ùå Error en detecci√≥n sem√°ntica: {e}")
        return None

def buscar_respuesta_semantica_con_score(mensaje: str, umbral=0.88):
    try:
        embedding_usuario = openai.Embedding.create(
            model="text-embedding-ada-002",
            input=mensaje
        )["data"][0]["embedding"]
        embedding_usuario = np.array(embedding_usuario)

        mejor_score = 0
        mejor_pregunta = None
        mejor_respuesta = None

        for item in faq_respuestas:
            emb_faq = item.get("embedding")
            if emb_faq is not None:
                similitud = np.dot(embedding_usuario, emb_faq) / (norm(embedding_usuario) * norm(emb_faq))
                if similitud > mejor_score:
                    mejor_score = similitud
                    mejor_pregunta = item["pregunta"]
                    mejor_respuesta = item["respuesta"]

        if mejor_score >= umbral:
            return mejor_pregunta, mejor_respuesta, mejor_score
        return None

    except Exception as e:
        print(f"‚ùå Error en buscar_respuesta_semantica_con_score: {e}")
        return None

# Configuraci√≥n de la clave de API de OpenAI
openai.api_key = os.getenv("OPENAI_API_KEY")
if not openai.api_key:
    raise ValueError("OPENAI_API_KEY no est√° configurada en las variables de entorno.")

# Configuraci√≥n de la URL de la base de datos PostgreSQL
DATABASE_URL = "postgresql://my_postgres_db_oahe_user:AItPOENiOHIGPNva0eiCT0kK1od4UhZf@dpg-ctqqj0bqf0us73f4ar1g-a/my_postgres_db_oahe"

# Generaci√≥n de respuestas con OpenAI
def generar_respuesta_con_openai(prompt, contador: int = 0, user_id: str = "", mensaje_usuario: str = "", mensaje_original: str = ""):
    try:
        print("\n===== DEPURACI√ìN - GENERACI√ìN DE RESPUESTA CON OPENAI =====")
        print(f"üì§ Prompt enviado a OpenAI: {prompt}\n")

        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=150,
            temperature=0.3
        )

        respuesta = response.choices[0].message['content'].strip()
        print(f"üì• Respuesta generada por OpenAI: {respuesta}\n")

        # ‚ùå Filtro para menci√≥n indebida a contacto antes de interacci√≥n 5, 9 o 10+
        if (
            "bustamante" in respuesta.lower()
            and contador not in [5, 9] and contador < 10
            and not es_consulta_contacto(mensaje_usuario, user_id, mensaje_original)
        ):
            respuesta_filtrada = re.sub(
                r"(con\s+)?(el\s+)?Lic(\.|enciado)?\s+Daniel\s+O\.?\s+Bustamante.*?(\.|\n|$)",
                "", respuesta, flags=re.IGNORECASE
            )
            print("üîí Menci√≥n indebida al Lic. Bustamante detectada y eliminada.\n")
            return respuesta_filtrada.strip()

        return respuesta

    except Exception as e:
        print(f"‚ùå Error al generar respuesta con OpenAI: {e}")
        return "Lo siento, hubo un problema al generar una respuesta. Por favor, intenta nuevamente."

def estandarizar_emocion_detectada(emocion: str) -> str:
    emocion = emocion.strip().lower()
    emocion = re.sub(r"[.,;:!¬°¬ø?]+$", "", emocion)
    return emocion

def es_tema_clinico_o_emocional(mensaje: str) -> bool:
    if not mensaje or not isinstance(mensaje, str):
        return False

    mensaje = mensaje.lower().strip()

    # Palabras clave cl√≠nicas frecuentes
    palabras_clave = [
        "triste", "ansioso", "angustia", "ansiedad", "vac√≠o", "dolor", "sufrimiento",
        "miedo", "enojo", "culpa", "verg√ºenza", "desesperanza", "soledad", "estr√©s",
        "abandono", "apat√≠a", "insomnio", "despersonalizaci√≥n", "fobia", "ataques de p√°nico",
        "indecisi√≥n s√∫bita", "desborde", "desbordamiento", "nervioso", "desesperado",
        "indiferente", "ya no siento", "nada me entusiasma", "me quiero morir",
        "pienso en morirme", "no me reconozco", "todo me supera", "no puedo dormir"
    ]
    if any(palabra in mensaje for palabra in palabras_clave):
        return True

    # Patrones t√≠picos de malestar emocional
    patrones_emocionales = [
        r"me cuesta\s+(vivir|seguir|levant[a-z]+|encontrarle sentido)",
        r"no\s+(puedo|quiero|logro)\b.*",
        r"ya no\s+(disfruto|me interesa|me importa)",
        r"siento que\s+(todo est√° mal|no valgo|todo es en vano)",
        r"me siento\s+(perdido|vac√≠o|cansado|agotado|confundido|sin sentido)",
        r"no le encuentro sentido\s+(a la vida|a nada|a esto)",
        r"no tengo ganas", r"nada me importa", r"todo me cuesta", r"nada vale la pena",
        r"no sirvo para nada", r"siento que no sirvo", r"me cuesta\s+(vivir|seguir|todo)",
        r"no s√© si esto es normal", r"me siento perdido", r"siento que no puedo m√°s",
        r"me siento solo", r"todo me da igual", r"me tiene sin ganas",
        r"no duermo", r"no puedo dormir", r"no tengo energ√≠a",
    ]
    if any(re.search(p, mensaje) for p in patrones_emocionales):
        return True

    # ‚ö†Ô∏è Nuevos patrones de aislamiento o desinter√©s confundidos con cortes√≠a
    patrones_aislamiento = [
        r"\bno\s+me\s+interesa\s+hablar\s+con\s+nadie\b",
        r"\bno\s+quiero\s+hablar\s+con\s+nadie\b",
        r"\bno\s+quiero\s+ver\s+a\s+nadie\b",
        r"\bno\s+tengo\s+ganas\s+de\s+hablar\b",
        r"\bprefiero\s+estar\s+solo[a]?\b",
        r"\bquiero\s+aislarme\b"
    ]
    if any(re.search(p, mensaje) for p in patrones_aislamiento):
        return True

    return False


# üìé Respuesta profesional para mensajes fuera de contexto cl√≠nico o emocional
def respuesta_default_fuera_de_contexto():
    return (
        "Este espacio est√° destinado exclusivamente a consultas vinculadas al bienestar emocional y psicol√≥gico. "
        "Si lo que quer√©s compartir tiene relaci√≥n con alguna inquietud personal, emocional o cl√≠nica, "
        "estoy disponible para acompa√±arte desde ese lugar."
    )


# Funci√≥n para detectar emociones negativas usando OpenAI
def detectar_emociones_negativas(mensaje):
    prompt = (
        "Analiz√° el siguiente mensaje desde una perspectiva cl√≠nica y detect√° exclusivamente emociones negativas o estados afectivos vinculados a malestar psicol√≥gico. "
        "Tu tarea es identificar manifestaciones emocionales que indiquen sufrimiento, alteraci√≥n afectiva o malestar cl√≠nico.\n\n"

        "Indicaciones:\n"
        "- Devolv√© una lista separada por comas, sin explicaciones ni texto adicional.\n"
        "- Si hay ambig√ºedad, asign√° la emoci√≥n negativa m√°s cercana desde el punto de vista cl√≠nico.\n"
        "- Si hay m√∫ltiples emociones, incluilas todas separadas por comas.\n"
        "- Si no se detectan emociones negativas, devolv√© √∫nicamente: ninguna.\n\n"

        "Ejemplos cl√≠nicamente v√°lidos:\n"
        "- Emociones simples: tristeza, ansiedad, culpa, verg√ºenza, impotencia, miedo, irritabilidad, angustia.\n"
        "- Estados complejos: vac√≠o emocional, desgaste emocional, desesperanza, sensaci√≥n de abandono, temor al rechazo, apat√≠a profunda.\n\n"

        f"Mensaje: {mensaje}"
    )

    try:
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=50,
            temperature=0.0
        )
        emociones = response.choices[0].message.get("content", "").strip().lower()

        print("\n===== DEPURACI√ìN - DETECCI√ìN DE EMOCIONES =====")
        print(f"Mensaje analizado: {mensaje}")
        print(f"Respuesta de OpenAI: {emociones}")

        emociones = emociones.replace("emociones negativas detectadas:", "").strip()
        emociones = [emocion.strip() for emocion in emociones.split(",") if emocion.strip()]

        if "ninguna" in emociones:
            print("No se detectaron emociones negativas.\n")
            return []

        print(f"Emociones detectadas: {emociones}\n")
        return emociones

    except Exception as e:
        print(f"‚ùå Error al detectar emociones negativas: {e}")
        return []

# Generar frase disparadora seg√∫n emoci√≥n detectada
def generar_disparador_emocional(emocion):
    disparadores = {
        "tristeza": "La tristeza puede ser muy pesada. A veces aparece sin aviso y cuesta ponerla en palabras.",
        "ansiedad": "La ansiedad a veces no tiene una causa clara, pero se siente intensamente en el cuerpo y en los pensamientos.",
        "culpa": "La culpa suele cargar con cosas no dichas o no resueltas.",
        "enojo": "El enojo puede ser una forma de defensa frente a algo que doli√≥ primero.",
        "miedo": "El miedo muchas veces se disfraza de prudencia o de silencio, pero su impacto se nota.",
        "confusi√≥n": "La confusi√≥n puede surgir cuando algo en nuestro mundo interno se mueve sin aviso.",
        "desgano": "A veces el desgano no es flojera, sino cansancio de sostener tanto por dentro.",
        "agotamiento": "El agotamiento emocional aparece cuando dimos mucho y recibimos poco o nada.",
        "soledad": "La soledad puede sentirse incluso rodeado de personas. A veces es una falta de resonancia m√°s que de compa√±√≠a."
    }
    return disparadores.get(emocion.lower())

# Gestionar combinaci√≥n emocional devolviendo una frase o registr√°ndola si es nueva
def gestionar_combinacion_emocional(emocion1, emocion2):
    """
    Consulta la tabla 'disparadores_emocionales' para una frase cl√≠nica correspondiente a una combinaci√≥n de emociones.
    Si no la encuentra, registra autom√°ticamente la combinaci√≥n en 'combinaciones_no_registradas'.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        # Consulta para buscar el disparador emocional cl√≠nico, sin importar el orden
        consulta = """
            SELECT texto_disparador FROM disparadores_emocionales
            WHERE (emocion_1 = %s AND emocion_2 = %s)
               OR (emocion_1 = %s AND emocion_2 = %s)
            LIMIT 1;
        """
        cursor.execute(consulta, (emocion1, emocion2, emocion2, emocion1))
        resultado = cursor.fetchone()

        if resultado:
            conn.close()
            return resultado[0]

        # Registrar la combinaci√≥n no contemplada
        print(f"üÜï Combinaci√≥n emocional no registrada: {emocion1} + {emocion2}")
        cursor.execute("""
            INSERT INTO combinaciones_no_registradas (emocion_1, emocion_2)
            VALUES (%s, %s)
            ON CONFLICT DO NOTHING;
        """, (emocion1.lower(), emocion2.lower()))

        conn.commit()
        conn.close()
        return None

    except Exception as e:
        print(f"‚ùå Error al gestionar combinaci√≥n emocional: {e}")
        return None

# Inicializaci√≥n de FastAPI
app = FastAPI()

# Configuraci√≥n de CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configuraci√≥n de la base de datos PostgreSQL
def init_db():
    """
    Crea las tablas necesarias si no existen en PostgreSQL.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS palabras_clave (
                id SERIAL PRIMARY KEY,
                sintoma TEXT UNIQUE NOT NULL,
                cuadro TEXT NOT NULL
            );
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS interacciones (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                consulta TEXT NOT NULL,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS emociones_detectadas (
                id SERIAL PRIMARY KEY,
                emocion TEXT NOT NULL,
                contexto TEXT NOT NULL,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS faq_similitud_logs (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                consulta TEXT NOT NULL,
                pregunta_faq TEXT NOT NULL,
                similitud FLOAT NOT NULL,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS inferencias_cerebro_simulado (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                interaccion_id INTEGER NOT NULL,
                tipo TEXT NOT NULL,
                valor TEXT NOT NULL,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        conn.commit()
        conn.close()
        print("Base de datos inicializada en PostgreSQL.")
    except Exception as e:
        print(f"Error al inicializar la base de datos: {e}")

# ===================== OPERACIONES CL√çNICAS SOBRE 'palabras_clave' =====================

# Registrar un s√≠ntoma con cuadro cl√≠nico asignado por OpenAI si no se proporciona
def registrar_sintoma(sintoma: str, estado_emocional: str = None):
    """
    Registra un s√≠ntoma en la base de datos con su estado emocional.
    Si no se proporciona un estado, lo clasifica autom√°ticamente con OpenAI.
    """

    # Si no se proporciona un estado emocional, usar OpenAI para asignarlo
    if not estado_emocional or not estado_emocional.strip():
        try:
            prompt = (
                f"Asigna un estado emocional cl√≠nicamente relevante a la siguiente emoci√≥n o s√≠ntoma: '{sintoma}'.\n\n"
                "Seleccion√° un estado con base en categor√≠as cl√≠nicas como trastornos, s√≠ndromes o patrones emocionales reconocidos.\n\n"
                "Si no corresponde a ninguno en particular, clasific√° como 'Patr√≥n emocional detectado'.\n\n"
                "Respond√© exclusivamente con el nombre del estado, sin explicaciones.\n\n"
                "Ejemplos v√°lidos:\n"
                "- Trastorno de ansiedad\n"
                "- Cuadro de depresi√≥n\n"
                "- Estr√©s postraum√°tico\n"
                "- Baja autoestima\n"
                "- Desgaste emocional\n"
                "- Sentimientos de inutilidad\n"
                "- Trastorno de impulsividad\n"
                "- Insomnio cr√≥nico\n"
                "- Patr√≥n emocional detectado"
            )

            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=50,
                temperature=0
            )

            estado_emocional = response.choices[0].message["content"].strip()

            if not estado_emocional:
                print(f"‚ö†Ô∏è OpenAI devolvi√≥ vac√≠o. Se asignar√° 'Patr√≥n emocional detectado' para '{sintoma}'.")
                estado_emocional = "Patr√≥n emocional detectado"

            print(f"üß† OpenAI asign√≥ el estado emocional: {estado_emocional} para '{sintoma}'.")

        except Exception as e:
            print(f"‚ùå Error al clasificar '{sintoma}' con OpenAI: {e}")
            estado_emocional = "Patr√≥n emocional detectado"

    # Insertar o actualizar en la base de datos
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO palabras_clave (sintoma, estado_emocional)
            VALUES (%s, %s)
            ON CONFLICT (sintoma) DO UPDATE SET estado_emocional = EXCLUDED.estado_emocional;
        """, (sintoma.strip().lower(), estado_emocional))
        conn.commit()
        conn.close()
        print(f"‚úÖ S√≠ntoma '{sintoma}' registrado con estado emocional '{estado_emocional}'.")
    except Exception as e:
        print(f"‚ùå Error al registrar s√≠ntoma '{sintoma}' en la base: {e}")

def actualizar_sintomas_sin_estado_emocional():
    """
    Busca s√≠ntomas en la base de datos que no tienen estado_emocional asignado,
    les solicita una clasificaci√≥n cl√≠nica a OpenAI y actualiza la tabla.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        # Obtener s√≠ntomas sin estado emocional asignado
        cursor.execute("SELECT sintoma FROM palabras_clave WHERE estado_emocional IS NULL;")
        sintomas_pendientes = [row[0] for row in cursor.fetchall()]
        conn.close()

        if not sintomas_pendientes:
            print("‚úÖ No hay s√≠ntomas pendientes de clasificaci√≥n en estado_emocional.")
            return

        print(f"üîç Clasificando {len(sintomas_pendientes)} s√≠ntomas sin estado_emocional...")

        for sintoma in sintomas_pendientes:
            prompt = (
                f"Asign√° un estado emocional cl√≠nico adecuado al siguiente s√≠ntoma: '{sintoma}'.\n\n"
                "Seleccion√° un estado emocional cl√≠nico compatible con clasificaciones como: Trastorno de ansiedad, Depresi√≥n mayor, Estr√©s postraum√°tico, "
                "Trastorno de p√°nico, Baja autoestima, Desgaste emocional, Sentimientos de aislamiento, Insomnio cr√≥nico, etc.\n\n"
                "Si el s√≠ntoma no se vincula a un estado cl√≠nico espec√≠fico, respond√© con: 'Patr√≥n emocional detectado'.\n\n"
                "Devolv√© exclusivamente el nombre del estado emocional sin texto adicional ni explicaciones."
            )

            try:
                respuesta = openai.ChatCompletion.create(
                    model="gpt-4",
                    messages=[{"role": "user", "content": prompt}],
                    max_tokens=50,
                    temperature=0.0
                )

                estado_emocional = respuesta["choices"][0]["message"]["content"].strip()
                print(f"üìå Estado emocional para '{sintoma}': {estado_emocional}")

                # Actualizar en la base de datos
                conn = psycopg2.connect(DATABASE_URL)
                cursor = conn.cursor()
                cursor.execute(
                    "UPDATE palabras_clave SET estado_emocional = %s WHERE sintoma = %s;",
                    (estado_emocional, sintoma)
                )
                conn.commit()
                conn.close()

            except Exception as e:
                print(f"‚ö†Ô∏è Error al clasificar o actualizar '{sintoma}': {e}")

    except Exception as e:
        print(f"‚ùå Error al conectar con la base de datos para actualizar estado_emocional: {e}")

# Obtener s√≠ntomas existentes
def obtener_sintomas_existentes():
    """
    Obtiene todos los s√≠ntomas almacenados en la base de datos PostgreSQL y los devuelve como un conjunto en min√∫sculas.
    Esto mejora la comparaci√≥n y evita problemas con may√∫sculas/min√∫sculas.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT LOWER(sintoma) FROM palabras_clave")  # Convierte a min√∫sculas desde la BD
        sintomas = {row[0] for row in cursor.fetchall()}  # Convierte en un conjunto para b√∫squeda eficiente
        conn.close()
        return sintomas
    except Exception as e:
        print(f"‚ùå Error al obtener s√≠ntomas existentes: {e}")
        return set()

# ===================== REGISTRO DE EMOCIONES DETECTADAS =====================

def registrar_emocion(emocion: str, contexto: str, user_id: str = None):
    """
    Registra una emoci√≥n detectada en la base de datos PostgreSQL.
    Si ya existe, actualiza el contexto concatenando. Si no existe, la inserta.
    Si la tabla tiene una columna 'user_id', se registra tambi√©n.
    """
    try:
        print("\n======= üìå REGISTRO DE EMOCI√ìN DETECTADA =======")
        print(f"üß† Emoci√≥n detectada: {emocion}")
        print(f"üßæ Contexto asociado: {contexto}")
        print(f"üë§ Usuario: {user_id if user_id else 'No especificado'}")

        with psycopg2.connect(DATABASE_URL) as conn:
            with conn.cursor() as cursor:
                # Verifica si la columna user_id existe
                cursor.execute("""
                    SELECT column_name FROM information_schema.columns 
                    WHERE table_name = 'emociones_detectadas' AND column_name = 'user_id';
                """)
                tiene_user_id = bool(cursor.fetchone())

                # Verifica si ya existe una emoci√≥n con o sin user_id
                if tiene_user_id and user_id:
                    cursor.execute(
                        "SELECT contexto FROM emociones_detectadas WHERE emocion = %s AND user_id = %s;",
                        (emocion.strip().lower(), user_id)
                    )
                else:
                    cursor.execute(
                        "SELECT contexto FROM emociones_detectadas WHERE emocion = %s;",
                        (emocion.strip().lower(),)
                    )

                resultado = cursor.fetchone()

                if resultado:
                    nuevo_contexto = f"{resultado[0]}; {contexto.strip()}"
                    if tiene_user_id and user_id:
                        cursor.execute(
                            "UPDATE emociones_detectadas SET contexto = %s WHERE emocion = %s AND user_id = %s;",
                            (nuevo_contexto, emocion.strip().lower(), user_id)
                        )
                    else:
                        cursor.execute(
                            "UPDATE emociones_detectadas SET contexto = %s WHERE emocion = %s;",
                            (nuevo_contexto, emocion.strip().lower())
                        )
                    print("üîÑ Emoci√≥n existente. Contexto actualizado.")
                else:
                    if tiene_user_id and user_id:
                        cursor.execute(
                            "INSERT INTO emociones_detectadas (emocion, contexto, user_id) VALUES (%s, %s, %s);",
                            (emocion.strip().lower(), contexto.strip(), user_id)
                        )
                    else:
                        cursor.execute(
                            "INSERT INTO emociones_detectadas (emocion, contexto) VALUES (%s, %s);",
                            (emocion.strip().lower(), contexto.strip())
                        )
                    print("üÜï Nueva emoci√≥n registrada exitosamente.")

                conn.commit()

        print("===============================================\n")

    except Exception as e:
        print(f"‚ùå Error al registrar emoci√≥n '{emocion}': {e}")



# ===================== REGISTRO DE INTERACCIONES Y RESPUESTAS =====================

# Registrar una interacci√≥n (versi√≥n extendida)
def registrar_interaccion(user_id: str, consulta: str, mensaje_original: str = None):
    try:
        print("\n===== DEPURACI√ìN - REGISTRO DE INTERACCI√ìN =====")
        print(f"Intentando registrar interacci√≥n: user_id={user_id}")
        print(f"Consulta purificada: {consulta}")
        print(f"Mensaje original: {mensaje_original}")

        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        # Verifica si la columna "mensaje_original" existe; si no, la crea autom√°ticamente
        cursor.execute("""
            SELECT column_name FROM information_schema.columns 
            WHERE table_name = 'interacciones' AND column_name = 'mensaje_original';
        """)
        columna_existente = cursor.fetchone()

        if not columna_existente:
            print("‚ö†Ô∏è La columna 'mensaje_original' no existe. Cre√°ndola...")
            cursor.execute("ALTER TABLE interacciones ADD COLUMN mensaje_original TEXT;")
            conn.commit()

        # Inserta la interacci√≥n con el mensaje original
        cursor.execute("""
            INSERT INTO interacciones (user_id, consulta, mensaje_original) 
            VALUES (%s, %s, %s) RETURNING id;
        """, (user_id, consulta, mensaje_original))
        
        interaccion_id = cursor.fetchone()[0]
        conn.commit()
        conn.close()

        print(f"‚úÖ Interacci√≥n registrada con √©xito. ID asignado: {interaccion_id}\n")
        return interaccion_id

    except Exception as e:
        print(f"‚ùå Error al registrar interacci√≥n en la base de datos: {e}\n")
        return None

# Registrar una respuesta generada por OpenAI en la base de datos
def registrar_respuesta_openai(interaccion_id: int, respuesta: str):
    """
    Registra la respuesta generada por OpenAI en la base de datos PostgreSQL.
    """
    try:
        print("\n===== DEPURACI√ìN - REGISTRO DE RESPUESTA OPENAI =====")
        print(f"Intentando registrar respuesta para interacci√≥n ID={interaccion_id}")

        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        
        # Verifica si la columna "respuesta" ya existe en la tabla "interacciones"
        cursor.execute("""
            SELECT column_name FROM information_schema.columns 
            WHERE table_name = 'interacciones' AND column_name = 'respuesta';
        """)
        columna_existente = cursor.fetchone()

        if not columna_existente:
            print("‚ö†Ô∏è La columna 'respuesta' no existe en la tabla 'interacciones'. Cre√°ndola...")
            cursor.execute("ALTER TABLE interacciones ADD COLUMN respuesta TEXT;")
            conn.commit()

        # Actualiza la interacci√≥n con la respuesta generada por OpenAI
        cursor.execute("""
            UPDATE interacciones 
            SET respuesta = %s 
            WHERE id = %s;
        """, (respuesta, interaccion_id))
        
        conn.commit()
        conn.close()
        
        print(f"‚úÖ Respuesta registrada con √©xito para interacci√≥n ID={interaccion_id}\n")

    except Exception as e:
        print(f"‚ùå Error al registrar respuesta en la base de datos: {e}\n")


def registrar_auditoria_input_original(user_id: str, mensaje_original: str, mensaje_purificado: str, clasificacion: str = None):
    """
    Registra el input original, su versi√≥n purificada y la clasificaci√≥n contextual (opcional) en una tabla de auditor√≠a.
    Permite trazabilidad entre lo que dijo el usuario y c√≥mo fue interpretado.
    """
    try:
        print("\nüìã Registrando input original y purificado en auditor√≠a")
        print(f"üë§ user_id: {user_id}")
        print(f"üìù Original: {mensaje_original}")
        print(f"üßº Purificado: {mensaje_purificado}")
        print(f"üè∑Ô∏è Clasificaci√≥n: {clasificacion}")

        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        # Crear tabla si no existe, con columna de clasificaci√≥n incluida
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS auditoria_input_original (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                mensaje_original TEXT NOT NULL,
                mensaje_purificado TEXT NOT NULL,
                clasificacion TEXT,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)

        # Insertar datos con clasificaci√≥n
        cursor.execute("""
            INSERT INTO auditoria_input_original (
                user_id, mensaje_original, mensaje_purificado, clasificacion
            ) VALUES (%s, %s, %s, %s);
        """, (user_id, mensaje_original.strip(), mensaje_purificado.strip(), clasificacion))

        conn.commit()
        conn.close()
        print("‚úÖ Auditor√≠a registrada exitosamente.\n")

    except Exception as e:
        print(f"‚ùå Error al registrar auditor√≠a del input original: {e}")


# Registrar una similitud sem√°ntica en la base de datos
def registrar_similitud_semantica(user_id: str, consulta: str, pregunta_faq: str, similitud: float):
    """
    Registra la similitud sem√°ntica en la tabla faq_similitud_logs.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        cursor.execute("""
            INSERT INTO faq_similitud_logs (user_id, consulta, pregunta_faq, similitud)
            VALUES (%s, %s, %s, %s);
        """, (user_id, consulta, pregunta_faq, similitud))

        conn.commit()
        conn.close()
        print(f"üß† Similitud registrada con √©xito (Score: {similitud}) para FAQ: '{pregunta_faq}'\n")

    except Exception as e:
        print(f"‚ùå Error al registrar similitud sem√°ntica: {e}")

def registrar_inferencia(user_id: str, interaccion_id: int, tipo: str, valor: str):
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        cursor.execute("""
            INSERT INTO inferencias_cerebro_simulado (user_id, interaccion_id, tipo, valor)
            VALUES (%s, %s, %s, %s);
        """, (user_id, interaccion_id, tipo, valor))

        conn.commit()
        conn.close()
        print(f"üß† Inferencia registrada: [{tipo}] ‚Üí {valor}")

    except Exception as e:
        print(f"‚ùå Error al registrar inferencia: {e}")


# Lista de palabras irrelevantes
palabras_irrelevantes = {
    "un", "una", "el", "la", "lo", "es", "son", "estoy", "siento", "me siento", "tambien", "tambien tengo", "que", "de", "en", 
    "por", "a", "me", "mi", "tengo", "mucho", "muy", "un", "poco", "tengo", "animicos", "si", "supuesto", "frecuentes", "verdad", "s√©", "hoy", "quiero", 
    "bastante", "mucho", "tambien", "gente", "frecuencia", "entendi", "hola", "estoy", "vos", "entiendo", 
    "soy", "mi", "de", "es", "4782-6465", "me", "siento", "para", "mucha", "y", "sufro", "vida", 
    "que", "opinas", "¬ø","?", "reinicia", "con", "del", "necesito", "me", "das"
}

def purificar_input_clinico(texto: str) -> str:
    import re

    try:
        if not isinstance(texto, str):
            return ""

        texto_original = texto.strip().lower()

        texto = texto_original

        # üõ°Ô∏è Detectar negaci√≥n para no perder sentido cl√≠nico
        negadores_criticos = ["nada", "nadie", "ninguno", "ninguna", "no"]
        contiene_negador = any(re.search(rf'\b{n}\b', texto_original) for n in negadores_criticos)

        # üóëÔ∏è Limpieza de muletillas
        muletillas = [
            r'\b(este|eh+|mmm+|aj√°|tipo|digamos|sea|viste|bueno|a ver|me explico|ehh*)\b',
            r'\b(s√≠|si|claro)\b'
        ]
        for patron in muletillas:
            texto = re.sub(patron, '', texto, flags=re.IGNORECASE)

        texto = re.sub(r'\s{2,}', ' ', texto).strip()

        # ‚úÖ Coincidencias cl√≠nicas completas
        coincidencias_exactas = {
            "nada me entusiasma, ni siquiera lo que sol√≠a gustarme": "anhedonia",
            "nada me importa, ni lo que antes me importaba": "apat√≠a profunda",
            "no quiero ver a nadie ni salir de casa": "aislamiento",
            "pienso en morirme todo el tiempo": "ideaci√≥n suicida",
            "lloro sin raz√≥n y no s√© por qu√©": "llanto sin motivo"
        }
        for frase, valor in coincidencias_exactas.items():
            if frase in texto:
                texto = valor
                break

        # ‚úÇÔ∏è Limpieza final y estandarizaci√≥n gramatical
        texto = re.sub(r'\b(\w{1}) (\w+)', r'\1 \2', texto)
        texto = re.sub(r'(\.{2,})', '.', texto)
        texto = re.sub(r'(,{2,})', ',', texto)
        texto = re.sub(r'[\s\.,!?]+$', '', texto)
        texto = texto.strip()

        # Capitalizaci√≥n
        if texto:
            texto = texto[0].upper() + texto[1:]

        return texto

    except Exception as e:
        print(f"[Error] purificar_input_clinico: {e}")
        return ""

def clasificar_input_inicial(texto: str) -> str:
    if not texto or not isinstance(texto, str):
        return "OTRO"

    texto = texto.lower().strip()

    # üß† Cargar s√≠ntomas desde la BD si el set global est√° vac√≠o
    global sintomas_cacheados
    if not sintomas_cacheados:
        try:
            sintomas_existentes = obtener_sintomas_existentes()
            sintomas_cacheados.update(sintomas_existentes)
        except Exception as e:
            print(f"‚ùå Error al cargar s√≠ntomas cacheados en clasificar_input_inicial: {e}")

    # üëã Saludos y detecci√≥n combinada con malestar cl√≠nico
    saludos = ["hola", "buenos d√≠as", "buenas tardes", "buenas noches", "qu√© tal", "como est√°s", "como esta"]
    if any(s in texto for s in saludos) and es_tema_clinico_o_emocional(texto):
        return "CLINICO"
    if texto in saludos:
        return "SALUDO"

    # üôè Frases de agradecimiento o cortes√≠a
    expresiones_cortesia = [
        "gracias", "muchas gracias", "muy amable", "ok gracias", "perfecto, gracias", "mil gracias",
        "te agradezco", "todo bien", "no necesito m√°s", "me qued√≥ claro", "nada m√°s"
    ]
    if texto in expresiones_cortesia:
        return "CORTESIA"

    # üîé Consultas sobre modalidad de atenci√≥n (ubicaci√≥n, virtualidad)
    consultas_modalidad = [
        "es presencial", "es online", "son online", "es virtual", "atiende por videollamada", "por zoom",
        "se hace por videollamada", "atenci√≥n virtual", "por llamada", "me tengo que presentar",
        "se hace presencial", "ubicaci√≥n", "d√≥nde atiende", "donde atiende", "donde queda",
        "d√≥nde est√°", "ciudad", "zona", "provincia", "en qu√© parte est√°s", "d√≥nde es la consulta",
        "direcci√≥n", "en qu√© lugar se atiende", "d√≥nde se realiza", "debo ir al consultorio",
        "se hace a distancia", "atenci√≥n remota", "consultorio", "atenci√≥n online"
    ]
    if any(frase in texto for frase in consultas_modalidad):
        return "CONSULTA_MODALIDAD"

    # üß† Malestar cl√≠nico directo (abstracciones y s√≠ntomas)
    clinicos_ampliados = [
        "nada me entusiasma", "nada me importa", "nada tiene sentido", "no tengo ganas", "no me interesa nada",
        "no me dan ganas", "no siento nada", "me quiero morir", "pienso en morirme", "me siento vac√≠o", "no le encuentro sentido",
        "todo me supera", "ya no disfruto", "siento un peso", "me cuesta levantarme", "lloro sin raz√≥n", "me duele el alma",
        "estoy muy triste", "me siento solo", "no puedo m√°s", "no puedo dormir", "siento ansiedad", "me siento mal conmigo"
    ]
    if any(frase in texto for frase in clinicos_ampliados):
        return "CLINICO"

    # üßæ Consultas cl√≠nicas expl√≠citas disfrazadas de preguntas
    frases_consulta_directa = [
        "¬øatienden estos casos?", "¬øatiende estos casos?", "¬øatienden el caso?", "¬øatiende el caso?",
        "¬øtratan este tipo de temas?", "¬øtrata este tipo de temas?",
        "¬ømanejan este tipo de situaciones?", "¬ømanejan estos casos?",
        "¬øhacen tratamiento de esto?", "¬øhace tratamiento de esto?",
        "¬øel licenciado puede atender esto?", "¬øpueden ayudar con esto?",
        "¬øesto lo trata el profesional?", "¬øesto lo trabajan en terapia?",
        "¬øesto se trabaja en terapia?", "¬øeste tema lo abordan?"
    ]
    if any(frase in texto for frase in frases_consulta_directa):
        return "ADMINISTRATIVO"

    # üìã Consultas indirectas: verbo + tema cl√≠nico (frecuentes en landing pages)
    temas_clinicos_comunes = [
        "terapia de pareja", "psicoterapia", "tratamiento psicol√≥gico", "consultas psicol√≥gicas",
        "abordaje emocional", "tratamiento emocional", "atenci√≥n psicol√≥gica"
    ]
    for verbo in [
        "hace", "hacen", "dan", "atiende", "atienden", "realiza", "realizan", "ofrece", "ofrecen",
        "trabaja con", "trabajan con", "brinda", "brindan"
    ]:
        for tema in temas_clinicos_comunes:
            patron = rf"{verbo}\s*(el|la|los|las)?\s*{re.escape(tema)}"
            if re.search(patron, texto, re.IGNORECASE):
                registrar_auditoria_input_original(
                    user_id="sistema",
                    mensaje_original=texto,
                    mensaje_purificado=texto,
                    clasificacion="ADMINISTRATIVO (verbo + tema cl√≠nico com√∫n)"
                )
                return "ADMINISTRATIVO"

    # üß† Consultas indirectas sobre s√≠ntomas mediante verbos + s√≠ntomas cacheados
    verbos_consulta = [
        "trata", "tratan", "atiende", "atienden", "aborda", "abordan",
        "se ocupa de", "se ocupan de", "interviene en", "intervienen en",
        "trabaja con", "trabajan con", "hace tratamiento de", "hacen tratamiento de",
        "realiza tratamiento de", "realizan tratamiento de",
        "da tratamiento a", "dan tratamiento a", "maneja", "manejan",
        "ayuda con", "ayudan con", "acompa√±a en", "acompa√±an en",
        "resuelve", "resuelven", "puede tratar", "pueden tratar",
        "puede ayudar con", "pueden ayudar con", "atiende el tema de", "trata el tema de",
        "puede atender", "pueden atender", "est√° capacitado para tratar", "est√°n capacitados para tratar"
    ]
    for verbo in verbos_consulta:
        for sintoma in sintomas_cacheados:
            if verbo in texto and sintoma in texto:
                return "ADMINISTRATIVO"

    # üß† Evaluaci√≥n final: si el mensaje contiene s√≠ntomas o malestar
    if es_tema_clinico_o_emocional(texto):
        return "CLINICO"

    return "OTRO"


    # Expresiones t√≠picas de saludo
    saludos = ["hola", "buenas", "buenos d√≠as", "buenas tardes", "buenas noches", "qu√© tal", "como est√°s", "como esta"]
    if any(frase in texto for frase in saludos):
        return "SALUDO"

    # Frases de agradecimiento o cierre amable
    cortesias = ["gracias", "muy amable", "te agradezco", "muchas gracias", "ok gracias", "perfecto, gracias", "mil gracias", "gracias por todo"]
    if any(frase in texto for frase in cortesias):
        return "CORTESIA"

    # Consultas sobre modalidad de atenci√≥n (online/presencial) o ubicaci√≥n
    consultas_modalidad = [
        "es presencial", "es online", "son online", "es virtual", "atiende por videollamada", "por zoom",
        "se hace por videollamada", "atenci√≥n virtual", "por llamada", "me tengo que presentar",
        "se hace presencial", "ubicaci√≥n", "d√≥nde atiende", "donde atiende", "donde queda",
        "d√≥nde est√°", "ciudad", "zona", "provincia", "en qu√© parte est√°s", "d√≥nde es la consulta",
        "direcci√≥n", "en qu√© lugar se atiende", "d√≥nde se realiza", "debo ir al consultorio",
        "se hace a distancia", "atenci√≥n remota", "consultorio", "atenci√≥n online"
    ]
    
    if any(frase in texto for frase in consultas_modalidad):
        return "CONSULTA_MODALIDAD"

    
    # üß† Consultas indirectas sobre si se tratan ciertos cuadros emocionales usando s√≠ntomas cacheados
    verbos_consulta = [
        "trata", "tratan", "atiende", "atienden", "aborda", "abordan",
        "se ocupa de", "se ocupan de", "interviene en", "intervienen en",
        "trabaja con", "trabajan con", "hace tratamiento de", "hacen tratamiento de",
        "realiza tratamiento de", "realizan tratamiento de",
        "da tratamiento a", "dan tratamiento a", "maneja", "manejan",
        "ayuda con", "ayudan con", "acompa√±a en", "acompa√±an en",
        "resuelve", "resuelven", "puede tratar", "pueden tratar",
        "puede ayudar con", "pueden ayudar con", "atiende el tema de", "trata el tema de",
        "puede atender", "pueden atender", "est√° capacitado para tratar", "est√°n capacitados para tratar"
    ]
    
    # Frases interrogativas comunes que implican consulta cl√≠nica
    frases_consulta_directa = [
        "¬øatienden estos casos?", "¬øatiende estos casos?", "¬øatienden el caso?", "¬øatiende el caso?",
        "¬øtratan este tipo de temas?", "¬øtrata este tipo de temas?",
        "¬ømanejan este tipo de situaciones?", "¬ømanejan estos casos?",
        "¬øhacen tratamiento de esto?", "¬øhace tratamiento de esto?",
        "¬øel licenciado puede atender esto?", "¬øpueden ayudar con esto?",
        "¬øesto lo trata el profesional?", "¬øesto lo trabajan en terapia?",
        "¬øesto se trabaja en terapia?", "¬øeste tema lo abordan?"
    ]
    if any(frase in texto.lower() for frase in frases_consulta_directa):
        return "ADMINISTRATIVO"

    # Indicadores cl√≠nicos ampliados (incluso con negaciones o abstracciones emocionales)
    clinicos_ampliados = [
        "nada me entusiasma", "nada me importa", "nada tiene sentido", "no tengo ganas", "no me interesa nada",
        "no me dan ganas", "no siento nada", "me quiero morir", "pienso en morirme", "me siento vac√≠o", "no le encuentro sentido",
        "todo me supera", "ya no disfruto", "siento un peso", "me cuesta levantarme", "lloro sin raz√≥n", "me duele el alma",
        "estoy muy triste", "me siento solo", "no puedo m√°s", "no puedo dormir", "siento ansiedad", "me siento mal conmigo"
    ]
    if any(frase in texto for frase in clinicos_ampliados):
        return "CLINICO"

        # Verbos comunes que indican consulta sobre si se atienden determinados temas cl√≠nicos
    verbos_tratamiento = [
        "tratan", "atienden", "hacen", "realizan", "abordan", "se ocupan", 
        "manejan", "intervienen en", "trabajan con", "ayudan con", "dan tratamiento a"
    ]

    # Cargar din√°micamente los s√≠ntomas registrados en la base
    try:
        sintomas_existentes = obtener_sintomas_existentes()
    except Exception as e:
        print(f"‚ö†Ô∏è Error al obtener s√≠ntomas desde la base en clasificar_input_inicial: {e}")
        sintomas_existentes = []

    return "OTRO"


def obtener_sintomas_con_estado_emocional():
    """
    Devuelve una lista de tuplas (sintoma, estado_emocional) desde la base de datos.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT LOWER(sintoma), estado_emocional FROM palabras_clave")
        resultados = cursor.fetchall()
        conn.close()
        return resultados
    except Exception as e:
        print(f"‚ùå Error al obtener s√≠ntomas con estado emocional: {e}")
        return []

# An√°lisis de texto del usuario
def analizar_texto(mensajes_usuario):
    """
    Analiza los mensajes del usuario para detectar coincidencias con los s√≠ntomas almacenados
    y muestra un cuadro probable y emociones o patrones de conducta adicionales detectados.
    """
    sintomas_existentes = obtener_sintomas_con_estado_emocional()
    if not sintomas_existentes:
        return "No se encontraron s√≠ntomas en la base de datos para analizar."

    keyword_to_cuadro = {sintoma.lower(): cuadro for sintoma, cuadro in sintomas_existentes}
    sintomas_registrados = {sintoma.lower() for sintoma, _ in sintomas_existentes}

    coincidencias = []
    emociones_detectadas = []
    nuevos_sintomas = []

    for mensaje in mensajes_usuario:
        user_words = mensaje.lower().split()
        user_words = [
            palabra for palabra in user_words
            if palabra not in palabras_irrelevantes and len(palabra) > 2 and palabra.isalpha()
        ]

        for palabra in user_words:
            if palabra in keyword_to_cuadro:
                coincidencias.append(keyword_to_cuadro[palabra])
            elif palabra not in nuevos_sintomas:
                nuevos_sintomas.append(palabra)

    # Registrar s√≠ntomas nuevos sin cuadro cl√≠nico
    for sintoma in nuevos_sintomas:
        if sintoma not in sintomas_registrados:
            registrar_sintoma(sintoma, None)

    # Generar emociones detectadas si hay pocas coincidencias
    if len(coincidencias) < 2:
        texto_usuario = " ".join(mensajes_usuario)
        prompt = (
            f"Detect√° emociones negativas o patrones emocionales con implicancia cl√≠nica en el siguiente texto del usuario:\n\n"
            f"{texto_usuario}\n\n"
            "Identific√° √∫nicamente t√©rminos emocionalmente relevantes (individuales o compuestos), separados por comas, sin explicaciones adicionales.\n\n"
            "Si el contenido no incluye ning√∫n elemento cl√≠nico relevante, respond√© √∫nicamente con 'ninguna'."
        )

        try:
            emociones_detectadas = generar_respuesta_con_openai(prompt).split(",")
            emociones_detectadas = [
                emocion.strip().lower() for emocion in emociones_detectadas
                if emocion.strip().lower() not in palabras_irrelevantes
            ]

            for emocion in emociones_detectadas:
                registrar_sintoma(emocion, "patr√≥n emocional detectado")

        except Exception as e:
            print(f"Error al usar OpenAI para detectar emociones: {e}")

    if not coincidencias and not emociones_detectadas:
        return "No se encontraron suficientes coincidencias para determinar un cuadro probable."

    respuesta = ""
    if coincidencias:
        category_counts = Counter(coincidencias)
        cuadro_probable, _ = category_counts.most_common(1)[0]
        respuesta = (
            f"Con base en los s√≠ntomas detectados ({', '.join(set(coincidencias))}), "
            f"el malestar emocional predominante es: {cuadro_probable}. "
        )

    if emociones_detectadas:
        respuesta += (
            f"Adem√°s, notamos emociones o patrones de conducta humanos como {', '.join(set(emociones_detectadas))}, "
            f"por lo que sugiero solicitar una consulta con el Lic. Daniel O. Bustamante escribiendo al WhatsApp "
            f"+54 911 3310-1186 para una evaluaci√≥n m√°s detallada."
        )

    return respuesta

# Clase para solicitudes del usuario
class UserInput(BaseModel):
    mensaje: str
    user_id: str

# Gesti√≥n de sesiones (en memoria)
user_sessions = {}
SESSION_TIMEOUT = 60  # Tiempo en segundos para limpiar sesiones inactivas

# üß† Cache de s√≠ntomas registrados en la base
sintomas_cacheados = set()

@app.on_event("startup")
def startup_event():
    init_db()                          # üß± Inicializa la base de datos
    generar_embeddings_faq()          # üß† Genera embeddings de FAQ al iniciar
    start_session_cleaner()           # üßπ Limpia sesiones inactivas

    # üöÄ Inicializar cache de s√≠ntomas registrados
    global sintomas_cacheados
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("SELECT LOWER(sintoma) FROM palabras_clave")
        sintomas = cursor.fetchall()
        sintomas_cacheados = {s[0].strip() for s in sintomas if s[0]}
        conn.close()
        print(f"‚úÖ Cache inicial de s√≠ntomas cargado: {len(sintomas_cacheados)} √≠tems.")
    except Exception as e:
        print(f"‚ùå Error al inicializar cache de s√≠ntomas: {e}")


# Funci√≥n para limpiar sesiones inactivas
def start_session_cleaner():
    """
    Limpia las sesiones inactivas despu√©s de un tiempo definido (SESSION_TIMEOUT).
    """
    def cleaner():
        while True:
            current_time = time.time()
            inactive_users = [
                user_id for user_id, session in user_sessions.items()
                if current_time - session["ultima_interaccion"] > SESSION_TIMEOUT
            ]
            for user_id in inactive_users:
                del user_sessions[user_id]
            time.sleep(30)  # Intervalo para revisar las sesiones

    # Ejecutar la limpieza de sesiones en un hilo separado
    thread = threading.Thread(target=cleaner, daemon=True)
    thread.start()

# Manejo de respuestas repetitivas
def evitar_repeticion(respuesta, historial):
    respuestas_alternativas = [
        "Entiendo. ¬øPodr√≠as contarme m√°s sobre c√≥mo te sientes?",
        "Gracias por compartirlo. ¬øC√≥mo ha sido tu experiencia con esto?",
        "Eso parece importante. ¬øTe ha pasado antes?"
    ]
    if respuesta in historial:
        return random.choice(respuestas_alternativas)
    historial.append(respuesta)
    return respuesta

def obtener_coincidencias_sintomas_y_registrar(emociones):
    """
    Busca coincidencias de s√≠ntomas en la base de datos y devuelve una lista de estados emocionales relacionados.
    Si una emoci√≥n no tiene coincidencias exactas ni parciales, la registra en la base de datos para futura clasificaci√≥n.
    Luego, usa OpenAI para clasificar cualquier s√≠ntoma sin estado emocional asignado y lo actualiza en la base de datos.
    """
    if not emociones:
        return []

    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        print("\n===== DEPURACI√ìN SQL =====")
        print("Emociones detectadas:", emociones)

        # Buscar coincidencias exactas en la base de datos
        consulta = "SELECT sintoma, estado_emocional FROM palabras_clave WHERE sintoma = ANY(%s)"
        cursor.execute(consulta, (emociones,))
        resultados = cursor.fetchall()

        estados_emocionales = [resultado[1] for resultado in resultados]
        sintomas_existentes = [resultado[0] for resultado in resultados]

        print("S√≠ntomas encontrados en la BD:", sintomas_existentes)
        print("Estados emocionales encontrados:", estados_emocionales)

        # Identificar emociones que no est√°n en la base de datos y registrarlas sin estado emocional
        emociones_nuevas = [emocion for emocion in emociones if emocion not in sintomas_existentes]
        for emocion in emociones_nuevas:
            registrar_sintoma(emocion, None)  # Se registra sin estado emocional

        conn.commit()
        conn.close()

        # Ahora clasificamos los s√≠ntomas que se registraron sin estado emocional
        actualizar_sintomas_sin_estado_emocional()

        return estados_emocionales if estados_emocionales else []

    except Exception as e:
        print(f"‚ùå Error al obtener coincidencias de s√≠ntomas o registrar nuevos s√≠ntomas: {e}")
        return []

def obtener_emociones_ya_registradas(user_id, interaccion_id):
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cur = conn.cursor()
        cur.execute("""
            SELECT emocion FROM emociones_detectadas
            WHERE user_id = %s AND contexto = %s
        """, (user_id, f"interacci√≥n {interaccion_id}"))
        resultados = cur.fetchall()
        emociones = [r[0].lower().strip() for r in resultados]
        cur.close()
        conn.close()
        return emociones
    except Exception as e:
        print(f"‚ùå Error al obtener emociones ya registradas en la BD: {e}")
        return []

def obtener_combinaciones_no_registradas(dias=7):
    """
    Devuelve una lista de combinaciones emocionales detectadas por el bot pero que a√∫n no tienen frase registrada.
    Por defecto, muestra las registradas en los √∫ltimos 'dias' (7 por defecto).
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        # Calcular fecha l√≠mite
        fecha_limite = datetime.now() - timedelta(days=dias)

        consulta = """
            SELECT emocion_1, emocion_2, fecha 
            FROM combinaciones_no_registradas
            WHERE fecha >= %s
            ORDER BY fecha DESC;
        """
        cursor.execute(consulta, (fecha_limite,))
        combinaciones = cursor.fetchall()
        conn.close()

        print(f"\nüìã Combinaciones emocionales no registradas (√∫ltimos {dias} d√≠as):")
        for emocion_1, emocion_2, fecha in combinaciones:
            print(f" - {emocion_1} + {emocion_2} ‚Üí {fecha.strftime('%Y-%m-%d %H:%M')}")

        return combinaciones

    except Exception as e:
        print(f"‚ùå Error al obtener combinaciones no registradas: {e}")
        return []

# ===================== REGISTRO DE SIMILITUD SEM√ÅNTICA =====================

def registrar_log_similitud(user_id: str, consulta: str, pregunta_faq: str, similitud: float):
    """
    Registra en la base de datos la similitud sem√°ntica detectada entre una consulta del usuario
    y una de las preguntas frecuentes, junto con su score.
    """
    try:
        print("\n======= üìå REGISTRO DE SIMILITUD SEM√ÅNTICA =======")
        print(f"üë§ user_id: {user_id}")
        print(f"üó®Ô∏è Consulta: {consulta}")
        print(f"‚ùì Pregunta FAQ: {pregunta_faq}")
        print(f"üìè Score de similitud: {similitud:.4f}")

        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()

        cursor.execute("""
            INSERT INTO faq_similitud_logs (user_id, consulta, pregunta_faq, similitud)
            VALUES (%s, %s, %s, %s);
        """, (user_id, consulta, pregunta_faq, float(similitud)))

        conn.commit()
        conn.close()
        print("‚úÖ Similitud registrada correctamente.\n")

    except Exception as e:
        print(f"‚ùå Error al registrar log de similitud: {e}")

def registrar_auditoria_respuesta(user_id: str, respuesta_original: str, respuesta_final: str, motivo_modificacion: str = None):
    """
    Registra la respuesta original de OpenAI y su versi√≥n final (modificada) en una tabla de auditor√≠a.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS auditoria_respuestas (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                respuesta_original TEXT NOT NULL,
                respuesta_final TEXT NOT NULL,
                motivo_modificacion TEXT,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)  # Seguridad: autocrea la tabla si no existe

        cursor.execute("""
            INSERT INTO auditoria_respuestas (user_id, respuesta_original, respuesta_final, motivo_modificacion)
            VALUES (%s, %s, %s, %s);
        """, (user_id, respuesta_original.strip(), respuesta_final.strip(), motivo_modificacion))
        conn.commit()
        conn.close()
        print("üìë Auditor√≠a registrada en auditoria_respuestas.")
    except Exception as e:
        print(f"‚ùå Error al registrar auditor√≠a de respuesta: {e}")

def generar_resumen_clinico_y_estado(session: dict, contador: int) -> str:
    """
    Genera una respuesta cl√≠nica con base en emociones detectadas y s√≠ntomas coincidentes.
    Se aplica en la interacci√≥n 5 y 9, devolviendo s√≠ntomas literales y estado emocional predominante.
    """

    mensajes = session.get("mensajes", [])
    emociones_acumuladas = session.get("emociones_detectadas", [])

    # Detectar nuevas emociones
    emociones_detectadas = detectar_emociones_negativas(" ".join(mensajes)) or []

    # ‚úÖ Unificaci√≥n sin duplicados
    emociones_unificadas = list(set(emociones_acumuladas + emociones_detectadas))
    session["emociones_detectadas"] = emociones_unificadas

    if not emociones_unificadas:
        print(f"‚ö†Ô∏è No se detectaron emociones al llegar a la interacci√≥n {contador}")
        return (
            "No se identificaron emociones predominantes en este momento. "
            "Te sugiero contactar al Lic. Bustamante al WhatsApp +54 911 3310-1186 para una evaluaci√≥n m√°s precisa."
        )

    coincidencias_sintomas = obtener_coincidencias_sintomas_y_registrar(emociones_unificadas)
    cuadro_predominante = (
        Counter(coincidencias_sintomas).most_common(1)[0][0]
        if len(coincidencias_sintomas) >= 2 else
        "No se pudo establecer con certeza un estado emocional predominante."
    )

    emociones_literal = ", ".join(emociones_unificadas[:3])

    respuesta = (
        f"Con base a lo que has descripto ‚Äî{emociones_literal}‚Äî, "
        f"pareciera ser que el malestar emocional predominante es: {cuadro_predominante}. "
        f"Te sugiero considerar una consulta con el Lic. Daniel O. Bustamante escribi√©ndole al WhatsApp +54 911 3310-1186 para una evaluaci√≥n m√°s detallada."
    )

    print(f"üßæ Resumen cl√≠nico generado correctamente en interacci√≥n {contador}")
    session["mensajes"].clear()
    return respuesta

def inferir_emocion_no_dicha(emociones_detectadas: List[str], conexion_pgsql) -> Optional[str]:
    """
    Simula una inferencia cl√≠nica basada en combinaciones frecuentes.
    Sugiere una emoci√≥n no mencionada a√∫n por el usuario, usando la base de datos como memoria cl√≠nica.
    """
    if not emociones_detectadas:
        return None

    try:
        with conexion_pgsql.cursor() as cursor:
            cursor.execute("""
                SELECT estado_emocional, COUNT(*) as frecuencia
                FROM palabras_clave
                WHERE sintoma = ANY(%s)
                GROUP BY estado_emocional
                ORDER BY frecuencia DESC
                LIMIT 1
            """, (emociones_detectadas,))
            resultado = cursor.fetchone()
            if resultado and resultado[0].lower().strip() not in emociones_detectadas:
                return resultado[0]
    except Exception as e:
        print("‚ùå Error en inferencia emocional:", e)

    return None
    
def hay_contexto_clinico_anterior(user_id: str) -> bool:
    """
    Eval√∫a si ya hay emociones detectadas en la sesi√≥n del usuario.
    Se considera que hay contexto cl√≠nico previo si hay al menos una emoci√≥n registrada.
    """
    session = user_sessions.get(user_id)
    if session and session.get("emociones_detectadas"):
        return len(session["emociones_detectadas"]) >= 1
    return False

@app.post("/asistente")
async def asistente(input_data: UserInput):
    try:
        user_id = input_data.user_id
        mensaje_original = input_data.mensaje.strip()
        mensaje_usuario = mensaje_original.lower()

        # ‚úÖ Frases neutrales que no deben analizarse emocionalmente
        EXPRESIONES_DESCARTADAS = [
            # Cortes√≠a, cierre o testeo
            "gracias", "ok", "listo", "ya est√°", "nada m√°s", "solo eso", "solo quer√≠a saber eso",
            "me qued√≥ claro", "ya entend√≠", "era solo una duda", "era curiosidad", "me lo guardo",
            "te consultaba por otra persona", "me interesaba saber", "despu√©s veo", "lo consulto luego",
            "m√°s adelante veo", "ah ok", "claro", "entiendo", "lo veo despu√©s", "todo bien", "s√≠",
        
            # Preguntas neutras o generales
            "¬øa qui√©n me recomiendas?", "a qui√©n me recomiendas", "me recomendar√≠as a alguien?",
            "qu√© opinas?", "el atiende estos casos?", "que tipo de casos atienden?"
        ]

        # Comentarios metaconversacionales o de expectativa que no deben generar an√°lisis cl√≠nico
        EXPRESIONES_ESPERADAS_NO_CLINICAS = [
            "esto funciona como terapia", "me gustar√≠a que esto funcione como terapia",
            "es como una consulta", "esto parece una consulta", "esto me ayuda como si fuera terapia",
            "siento que esto es una sesi√≥n", "esto me resulta terap√©utico", "parece una sesi√≥n real"
        ]
        
        if any(expresion in mensaje_usuario for expresion in EXPRESIONES_ESPERADAS_NO_CLINICAS):
            registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, "EXPECTATIVA_NO_CLINICA")
            return {
                "respuesta": (
                    "Este espacio est√° dise√±ado para brindar orientaci√≥n cl√≠nica general. "
                    "Si hay algo puntual que te gustar√≠a compartir sobre tu estado emocional, pod√©s hacerlo con confianza."
                )
            }
        

        if not mensaje_usuario:
            raise HTTPException(status_code=400, detail="El mensaje no puede estar vac√≠o.")

        # üß© Clasificaci√≥n local por intenci√≥n general
        tipo_input = clasificar_input_inicial(mensaje_usuario)

        # üß† Inferencia cognitiva adicional sobre intenci√≥n del usuario
        intencion_inferida = inferir_intencion_usuario(mensaje_usuario)
        print(f"üß† Intenci√≥n inferida por el cerebro simulado: {intencion_inferida}")

        
        # ‚úÖ Forzar continuidad cl√≠nica si el input es ambiguo pero hubo malestar antes
        if tipo_input in ["INDEFINIDO", "FUERA_DE_CONTEXTO", "CONFUSO"]:
            if hay_contexto_clinico_anterior(user_id):
                tipo_input = CLINICO_CONTINUACION
        
        # üß† Registrar todas las etiquetas anteriores en la sesi√≥n
        session = user_sessions.get(user_id, {
            "contador_interacciones": 0,
            "ultima_interaccion": time.time(),
            "mensajes": [],
            "emociones_detectadas": [],
            "ultimas_respuestas": [],
            "input_sospechoso": False,
            "interacciones_previas": []
        })
        session.setdefault("interacciones_previas", []).append(tipo_input)
        user_sessions[user_id] = session
        
                
        if tipo_input == SALUDO:
            registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, SALUDO)
            return {"respuesta": "¬°Hola! ¬øEn qu√© puedo ayudarte hoy?"}
        
        elif tipo_input == CORTESIA:
            registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, CORTESIA)
            return {
                "respuesta": "Con gusto. Si necesit√°s algo m√°s, estoy disponible para ayudarte."
            }
        
        elif tipo_input == ADMINISTRATIVO:
            registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, ADMINISTRATIVO)
            return {
                "respuesta": (
                    "¬°Hola! Soy el asistente del Lic. Daniel O. Bustamante. "
                    + obtener_mensaje_contacto() +
                    "¬øHay algo m√°s que te gustar√≠a saber?"
                )
            }
        
        elif tipo_input == CLINICO_CONTINUACION:
            registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, CLINICO_CONTINUACION)
            return {
                "respuesta": (
                    "Entiendo. Lo que mencionaste antes podr√≠a estar indicando un malestar emocional. "
                    "¬øQuer√©s que exploremos un poco m√°s lo que est√°s sintiendo √∫ltimamente?"
                )
            }
        

        # üß† Clasificaci√≥n contextual con OpenAI
        try:
            prompt_contextual = (
                f"Analiz√° el siguiente mensaje del usuario y clasific√° su intenci√≥n principal, utilizando una √∫nica etiqueta v√°lida.\n\n"
                f"Mensaje: '{mensaje_usuario}'\n\n"
                "Posibles etiquetas (escribilas exactamente como est√°n):\n"
                "- CLINICO: si expresa malestar emocional, s√≠ntomas, angustia, ideas existenciales, desmotivaci√≥n, llanto, insomnio, vac√≠o, o cualquier signo de sufrimiento subjetivo.\n"
                "- CORTESIA: si solo agradece, cierra la conversaci√≥n o expresa buenos modales sin intenci√≥n emocional o cl√≠nica.\n"
                "- CONSULTA_AGENDAR: si consulta sobre turnos, disponibilidad, c√≥mo coordinar una sesi√≥n, c√≥mo pedir cita, c√≥mo sacar turno, cu√°nto cuesta, etc.\n"
                "- CONSULTA_MODALIDAD: si consulta por la modalidad de atenci√≥n (online/presencial), si es por videollamada, Zoom, ubicaci√≥n o si debe asistir a un consultorio.\n"
                "- TESTEO: si es un mensaje de prueba sin contenido emocional ni administrativo (ejemplo: 'hola test', 'probando', '1,2,3', etc.).\n"
                "- MALICIOSO: si contiene lenguaje t√©cnico, comandos, c√≥digo de programaci√≥n, frases extra√±as, manipulaci√≥n evidente o contenido ajeno a una conversaci√≥n cl√≠nica.\n"
                "- IRRELEVANTE: si no tiene relaci√≥n con la cl√≠nica psicol√≥gica ni con la consulta de servicios (ej: temas t√©cnicos, bromas, frases absurdas, etc.).\n\n"
                "Respond√© con una sola palabra en may√∫sculas, sin explicaciones adicionales. Solamente devolv√© la etiqueta elegida."
            )
     
            response_contextual = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt_contextual}],
                max_tokens=20,
                temperature=0.0
            )
        
            clasificacion = response_contextual.choices[0].message['content'].strip().upper()

            # üîç Validaci√≥n robusta
            opciones_validas = {
                "CLINICO", "CORTESIA", "CONSULTA_AGENDAR", "CONSULTA_MODALIDAD",
                "TESTEO", "MALICIOSO", "IRRELEVANTE"
            }
            if clasificacion not in opciones_validas:
                print(f"‚ö†Ô∏è Clasificaci√≥n inv√°lida recibida de OpenAI: '{clasificacion}'")
                clasificacion = "IRRELEVANTE"
            
            if clasificacion == "CORTESIA":
                registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, CORTESIA)
                return {"respuesta": "Con gusto. Si necesit√°s algo m√°s, estoy disponible para ayudarte."}
            
            if clasificacion == "CONSULTA_AGENDAR":
                registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, CONSULTA_AGENDAR)
                return {
                    "respuesta": (
                        "Para agendar una sesi√≥n o conocer disponibilidad, pod√©s escribirle directamente al Lic. Bustamante al WhatsApp +54 911 3310-1186."
                    )
                }
            
            if clasificacion == "CONSULTA_MODALIDAD":
                registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, CONSULTA_MODALIDAD)
                return {
                    "respuesta": (
                        "El Lic. Bustamante atiende exclusivamente en modalidad Online, a trav√©s de videollamadas. "
                        "Pod√©s consultarle directamente al WhatsApp +54 911 3310-1186 si quer√©s coordinar una sesi√≥n."
                    )
                }
            
            if clasificacion in ["TESTEO", "MALICIOSO", "IRRELEVANTE"]:
                registrar_auditoria_input_original(user_id, mensaje_original, mensaje_usuario, clasificacion)
            
                # ‚ö†Ô∏è Solo bloquear si no hay contexto cl√≠nico previo
                if not hay_contexto_clinico_anterior(user_id):
                    session["input_sospechoso"] = True
                    return {"respuesta": respuesta_default_fuera_de_contexto()}
                else:
                    # ‚ö†Ô∏è Forzar que siga el flujo cl√≠nico como continuaci√≥n
                    tipo_input = CLINICO_CONTINUACION
            
        
        except Exception as e:
            print(f"üß†‚ùå Error en clasificaci√≥n contextual: {e}")
        
        # üõ°Ô∏è Etapa de blindaje contra inputs maliciosos
        def es_input_malicioso(texto: str) -> bool:
            patrones_maliciosos = [
                r"(\bimport\b|\bos\b|\bsystem\b|\beval\b|\bexec\b|\bopenai\.api_key\b)",  # C√≥digo Python
                r"(\bdrop\b|\bdelete\b|\binsert\b|\bupdate\b).*?\b(table|database)\b",     # SQL Injection
                r"(--|#|;|//).*?(drop|delete|system|rm\s+-rf)",                             # Comentarios maliciosos
                r"<script.*?>|</script>",                                                  # HTML/JS malicioso
                r"\b(shutdown|reboot|rm\s+-rf|mkfs|chmod|chown)\b"                          # Shell commands peligrosos
            ]
            for patron in patrones_maliciosos:
                if re.search(patron, texto, re.IGNORECASE):
                    return True
            return False
        
        if es_input_malicioso(mensaje_usuario):
            print("‚ö†Ô∏èüîí Input malicioso detectado y bloqueado:")
            print(f"   üîπ Usuario ID: {user_id}")
            print(f"   üîπ Mensaje purificado: {mensaje_usuario}")
            print(f"   üîπ Mensaje original: {mensaje_original}")
            
            registrar_auditoria_input_original(
                user_id,
                mensaje_original,
                mensaje_usuario + " [‚ö†Ô∏è DETECTADO COMO INPUT MALICIOSO]",
                "MALICIOSO"
            )
            
            return {
                "respuesta": (
                    "El sistema ha detectado que tu mensaje contiene elementos t√©cnicos no compatibles con una consulta cl√≠nica. "
                    "Si ten√©s una duda o problema de salud emocional, pod√©s contarme con confianza."
                )
            }

        # Registrar interacci√≥n con mensaje original incluido
        interaccion_id = registrar_interaccion(user_id, mensaje_usuario, mensaje_original)

        # üîÑ Si el input actual es ambiguo, pero ya hubo emociones antes, forzar continuidad cl√≠nica
        if tipo_input in ["FUERA_DE_CONTEXTO", "INDEFINIDO", "CONFUSO", "OTRO"]:
            if hay_contexto_clinico_anterior(user_id):
                tipo_input = CLINICO_CONTINUACION

        # Actualiza la sesi√≥n del usuario
        session["ultima_interaccion"] = time.time()
        session["contador_interacciones"] += 1  # ‚úÖ Incrementar contador aqu√≠
        contador = session["contador_interacciones"]
        session["mensajes"].append(mensaje_usuario)
        
        # üîí Interacci√≥n 10: cierre profesional definitivo
        if contador == 10:
            emocion_inferida = session.get("emocion_inferida_9")
            if emocion_inferida and (
                emocion_inferida in mensaje_usuario or "s√≠" in mensaje_usuario or "me pasa" in mensaje_usuario
            ):
                if emocion_inferida not in session["emociones_detectadas"]:
                    session["emociones_detectadas"].append(emocion_inferida)
                    registrar_emocion(emocion_inferida, f"confirmaci√≥n de inferencia (interacci√≥n 10)", user_id)
        
            respuesta = (
                "He encontrado interesante nuestra conversaci√≥n, pero para profundizar m√°s en el an√°lisis de tu malestar, "
                "ser√≠a ideal que consultes con un profesional. Por ello, te sugiero que te contactes con el Lic. Bustamante. "
                "Lamentablemente, no puedo continuar con la conversaci√≥n m√°s all√° de este punto."
            )
        
            prediccion = predecir_evento_futuro(session["mensajes"])
            if prediccion != "sin predicci√≥n identificada":
                print(f"üîÆ Proyecci√≥n detectada: {prediccion}")
                registrar_inferencia(user_id, contador, "prediccion", prediccion)
                respuesta += f" Por otra parte, se identific√≥ que mencionaste una posible consecuencia o desenlace: {prediccion}."
        
            registrar_respuesta_openai(interaccion_id, respuesta)
            return {"respuesta": respuesta}      

        # ‚õî Interrupci√≥n anticipada si ya se detect√≥ input sospechoso
        if session.get("input_sospechoso"):
            return {
                "respuesta": (
                    "Record√° que este espacio est√° destinado a consultas cl√≠nicas. "
                    "Si necesit√°s ayuda emocional, cont√°melo con claridad."
                )
            }

        # üß† Nueva respuesta para la PRIMERA INTERACCI√ìN
        if contador == 1:
            # ‚ö†Ô∏è Reforzar que si es SALUDO + contenido cl√≠nico, se trate como cl√≠nico
            if tipo_input == SALUDO and es_tema_clinico_o_emocional(mensaje_usuario):
                tipo_input = CLINICO
        
            # ‚úÖ Si es cl√≠nico o hay contexto cl√≠nico previo, generar respuesta profesional
            if tipo_input in [CLINICO, CLINICO_CONTINUACION] or hay_contexto_clinico_anterior(user_id) or es_tema_clinico_o_emocional(mensaje_usuario):
                prompt = (
                    f"Mensaje recibido del usuario: '{mensaje_usuario}'.\n\n"
                    "Redact√° una respuesta breve, profesional y cl√≠nica como si fueras el asistente virtual del Lic. Daniel O. Bustamante, psic√≥logo.\n\n"
                    "Estilo y directrices obligatorias:\n"
                    "- Manten√© un tono cl√≠nico, sobrio, profesional y respetuoso.\n"
                    "- Comenz√° la respuesta con un saludo breve como 'Hola, ¬øqu√© tal?'.\n"
                    "- Si se detecta malestar emocional, formul√° una observaci√≥n objetiva con expresiones como: 'pareciera tratarse de...', 'podr√≠a vincularse a...', 'refiere a...' o 'se observa...'.\n"
                    "- Evit√° cualquier frase emocional simulada (ej: 'te entiendo', 'est√°s en buenas manos', 'no est√°s solo/a', 'tranquilo/a', etc.).\n"
                    "- No uses frases motivacionales ni lenguaje coloquial (evit√°: 'todo va a estar bien', 'cont√° conmigo', etc.).\n"
                    "- No uses lenguaje institucional como 'nuestro equipo', 'desde nuestro espacio', 'trabajamos en conjunto', etc.\n"
                    "- No brindes datos de contacto, precios, horarios, enlaces ni informaci√≥n administrativa.\n"
                    "- No recomiendes consultar con el Lic. Bustamante ni uses expresiones como 'consultar con un profesional', 'buscar ayuda especializada' u otras sugerencias impl√≠citas.\n"
                    "- No formules preguntas como ‚Äú¬øDese√°s que te facilite informaci√≥n sobre agendar?‚Äù ni menciones WhatsApp.\n"
                    "- No uses 'Estimado/a', ni encabezados de carta o email.\n"
                    "- Solamente si el mensaje es claramente cl√≠nico, gener√° una respuesta anal√≠tica breve y profesional.\n"
                    "- Si el mensaje no tiene contenido emocional o cl√≠nico relevante, devolv√© una frase neutra como: 'Gracias por tu mensaje. ¬øHay algo puntual que te gustar√≠a compartir o consultar en este espacio?'\n\n"
                    "IMPORTANTE:\n"
                    "- En las interacciones 1 a 4, nunca sugieras contacto ni derivaci√≥n, salvo que el usuario lo pida expl√≠citamente.\n"
                    "- Solo en las interacciones 5, 9 o a partir de la 10, pod√©s aceptar que se mencione el contacto si fue solicitado.\n"
                )
       
                respuesta_original = generar_respuesta_con_openai(prompt, contador, user_id, mensaje_usuario, mensaje_original)
        
                # Filtrado de seguridad y registro de auditor√≠a
                registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_original)
                registrar_respuesta_openai(interaccion_id, respuesta_original)
        
                return {"respuesta": respuesta_original}
        
            # üîπ Si no es cl√≠nico ni hay contexto previo, mantener respuesta neutra
            return {
                "respuesta": (
                    "Gracias por tu mensaje. ¬øHay algo puntual que te gustar√≠a compartir o consultar en este espacio?"
                )
            }


        # üü¢ Si la frase es neutral, de cortes√≠a o curiosidad, no analizar emocionalmente ni derivar
        if mensaje_usuario in EXPRESIONES_DESCARTADAS or any(p in mensaje_usuario for p in ["recomienda", "opin√°s", "atiende"]):
            return {
                "respuesta": (
                    "Gracias por tu mensaje. Si en alg√∫n momento dese√°s explorar una inquietud emocional, "
                    "estoy disponible para ayudarte desde este espacio."
                )
            }

                        
        # üîç Buscar coincidencia sem√°ntica en preguntas frecuentes
        resultado_semantico = buscar_respuesta_semantica_con_score(mensaje_usuario)
        if resultado_semantico:
            pregunta_faq, respuesta_semantica, similitud = resultado_semantico
        
            # Registrar respuesta en la interacci√≥n ya creada
            registrar_respuesta_openai(interaccion_id, respuesta_semantica)
        
            # Registrar similitud en la tabla correspondiente
            registrar_log_similitud(user_id, mensaje_usuario, pregunta_faq, similitud)
        
            return {"respuesta": respuesta_semantica}

        # üîç DEPURACI√ìN: Mostrar estado actual de la sesi√≥n
        print("\n===== DEPURACI√ìN - SESI√ìN DEL USUARIO =====")
        print(f"Usuario ID: {user_id}")
        print(f"Interacci√≥n actual: {contador}")
        print(f"Mensajes en la sesi√≥n: {session['mensajes']}")
        print(f"Emociones acumuladas antes del an√°lisis: {session['emociones_detectadas']}")
        print("========================================\n")
        
        # Detectar negaciones o correcciones
        if any(negacion in mensaje_usuario for negacion in ["no dije", "no eso", "no es as√≠", "eso no", "no fue lo que dije"]):
            return {"respuesta": "Entiendo, gracias por aclararlo. ¬øC√≥mo describir√≠as lo que sientes?"}


        # Manejo para "no s√©", "ninguna", "ni la menor idea" tras describir un s√≠ntoma
        if mensaje_usuario in ["no s√©", "ninguna", "ni la menor idea"]:
            if session["contador_interacciones"] >= 9 or session["mensajes"]:
                respuesta_clinica = generar_resumen_clinico_y_estado(session, contador)
                return {
                    "respuesta": (
                        f"{respuesta_clinica} En caso de que lo desees, pod√©s contactar al Lic. Daniel O. Bustamante escribi√©ndole al WhatsApp +54 911 3310-1186."
                    )
                }
            return {"respuesta": "Entendido, quedo a tu disposici√≥n. Si necesitas algo m√°s, no dudes en dec√≠rmelo."}

        
        if es_consulta_contacto(mensaje_usuario, user_id, mensaje_original):
            return {
                "respuesta": "Para contactar al Lic. Daniel O. Bustamante, pod√©s enviarle un mensaje al WhatsApp +54 911 3310-1186. √âl estar√° encantado de responderte."
            }

        
        # üîπ Proporciona el n√∫mero de contacto si el usuario pregunta por el "mejor psic√≥logo" o especialista recomendado
        if (
            "especialista" in mensaje_usuario or
            "mejor psic√≥logo" in mensaje_usuario or
            "mejor psicologo" in mensaje_usuario or
            "mejor terapeuta" in mensaje_usuario or
            "mejor psicoterapeuta" in mensaje_usuario or
            "el mejor" in mensaje_usuario or
            "a quien me recomendas" in mensaje_usuario or
            "que opinas" in mensaje_usuario or
            "qu√© opinas" in mensaje_usuario or
            "excelente psic√≥logo" in mensaje_usuario or
            "buen profesional" in mensaje_usuario or
            "que me recomendas" in mensaje_usuario
        ):
            return {
                "respuesta": "En mi opini√≥n, el Lic. Daniel O. Bustamante es un excelente especialista en psicolog√≠a cl√≠nica. Seguramente podr√° ayudarte. "
                             "Puedes enviarle un mensaje al WhatsApp +54 911 3310-1186. √âl estar√° encantado de responderte."
            }

        # Manejo para "solo un s√≠ntoma y no m√°s" (responder como en la 5¬™ interacci√≥n y finalizar)
        if "no quiero dar m√°s s√≠ntomas" in mensaje_usuario or "solo este s√≠ntoma" in mensaje_usuario:
            mensajes = session["mensajes"]
            mensajes.append(mensaje_usuario)
            respuesta_analisis = analizar_texto(mensajes)
            session["mensajes"].clear()
            return {
                "respuesta": (
                    f"{respuesta_analisis} Si necesitas un an√°lisis m√°s profundo, tambi√©n te recomiendo contactar al Lic. Daniel O. Bustamante al WhatsApp "
                    f"+54 911 3310-1186 para una evaluaci√≥n m√°s detallada."
                )
            }
           
        # Obtener la lista de s√≠ntomas ya registrados en la BD
        sintomas_existentes = obtener_sintomas_existentes()
        
        # Detectar emociones desde el mensaje actual
        emociones_detectadas = detectar_emociones_negativas(mensaje_usuario) or []
        
        # Filtrar emociones detectadas para evitar registrar duplicados
        emociones_nuevas = []
        
        for emocion in emociones_detectadas:
            emocion = emocion.lower().strip()

            # üßº Estandarizar emoci√≥n detectada (eliminar puntuaci√≥n final innecesaria)
            emocion = re.sub(r'[^\w\s√°√©√≠√≥√∫√º√±]+$', '', emocion)
        
            # Verificar si la emoci√≥n ya fue detectada en la sesi√≥n para evitar registrar duplicados
            if emocion not in session["emociones_detectadas"]:
        
                # Si la emoci√≥n no est√° en la BD, agregarla a emociones_nuevas y registrar el s√≠ntoma
                if emocion not in sintomas_existentes:
                    emociones_nuevas.append(emocion)
                    registrar_sintoma(emocion)  # ‚úÖ Registrar en palabras_clave solo si no existe

        
        # üîç Depuraci√≥n: Mostrar qu√© emociones se intentar√°n registrar
        print(f"üîç Emociones nuevas que intentar√°n registrarse en palabras_clave: {emociones_nuevas}")
                
        # Registrar solo las emociones nuevas en la base de datos con un cuadro cl√≠nico asignado por OpenAI
        for emocion in emociones_nuevas:
            # Generar el prompt para OpenAI
            prompt_cuadro = (
                f"A partir de la siguiente emoci√≥n detectada: '{emocion}', asign√° un √∫nico cuadro cl√≠nico o patr√≥n emocional.\n\n"
                "Tu tarea es analizar el s√≠ntoma y determinar el estado cl√≠nico m√°s adecuado, bas√°ndote en criterios diagn√≥sticos de la psicolog√≠a o la psiquiatr√≠a. "
                "No respondas con explicaciones, s√≥lo con el nombre del cuadro cl√≠nico m√°s pertinente.\n\n"
                "Si la emoci√≥n no corresponde a ning√∫n cuadro cl√≠nico definido, indic√° √∫nicamente: 'Patr√≥n emocional detectado'.\n\n"
                "Ejemplos v√°lidos de cuadros cl√≠nicos:\n"
                "- Trastorno de ansiedad\n"
                "- Depresi√≥n mayor\n"
                "- Estr√©s postraum√°tico\n"
                "- Trastorno de p√°nico\n"
                "- Baja autoestima\n"
                "- Estado confusional\n"
                "- Desgaste emocional\n"
                "- Trastorno de impulsividad\n"
                "- Insomnio cr√≥nico\n"
                "- Desorientaci√≥n emocional\n"
                "- Sentimientos de aislamiento\n"
                "- Patr√≥n emocional detectado\n\n"
                "Devolv√© √∫nicamente el nombre del cuadro cl√≠nico, sin explicaciones, ejemplos ni texto adicional."
            )
        
            try:
                # Llamada a OpenAI para obtener el cuadro cl√≠nico
                response = openai.ChatCompletion.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": prompt_cuadro}],
                    max_tokens=50,
                    temperature=0.0
                )
        
                cuadro_asignado = response.choices[0].message['content'].strip()
        
                # Si OpenAI no devuelve un cuadro v√°lido, asignar un valor por defecto
                if not cuadro_asignado:
                    cuadro_asignado = "Patr√≥n emocional detectado"
        
                # Registrar la emoci√≥n con el cuadro cl√≠nico asignado
                registrar_sintoma(emocion, cuadro_asignado)
                print(f"üß† OpenAI asign√≥ el cuadro cl√≠nico: {cuadro_asignado} para la emoci√≥n '{emocion}'.")
                
                # üîÑ Agregar el nuevo s√≠ntoma al set cacheado en memoria
                sintomas_cacheados.add(emocion.lower().strip())
                
                        
            except Exception as e:
                print(f"‚ùå Error al obtener el cuadro cl√≠nico de OpenAI para '{emocion}': {e}")

        
        # üîç Confirmaci√≥n final de emociones registradas
        if emociones_nuevas:
            print(f"‚úÖ Se registraron las siguientes emociones nuevas en palabras_clave: {emociones_nuevas}")
        else:
            print("‚úÖ No hubo emociones nuevas para registrar en palabras_clave.")


        # Evitar agregar duplicados en emociones detectadas
        nuevas_emociones = [e for e in emociones_detectadas if e not in session["emociones_detectadas"]]
        session["emociones_detectadas"].extend(nuevas_emociones)
        
        # ‚úÖ Registrar emociones en la base solo si a√∫n no est√°n registradas en esta interacci√≥n
        emociones_registradas_bd = obtener_emociones_ya_registradas(user_id, contador)
        
        for emocion in session["emociones_detectadas"]:
            if emocion not in emociones_registradas_bd:
                registrar_emocion(emocion, f"interacci√≥n {contador}", user_id)

        # üß† Detecci√≥n de patrones reiterativos en interacciones 6 a 8
        if 6 <= contador <= 8:
            patron_detectado = inferir_patron_interactivo(session["mensajes"][-3:])
            if patron_detectado != "sin patr√≥n consistente":
                print(f"üîÑ Patr√≥n interactivo detectado: {patron_detectado}")
        
        # ‚úÖ En la interacci√≥n 5 y 9, generar resumen cl√≠nico y estado emocional predominante
        if contador == 5:
            if not session["emociones_detectadas"]:
                nuevas = detectar_emociones_negativas(" ".join(session["mensajes"])) or []
                session["emociones_detectadas"].extend([e for e in nuevas if e not in session["emociones_detectadas"]])
        
            resumen = generar_resumen_clinico_y_estado(session, contador)
        
            # üß† Realizar inferencia cl√≠nica intuitiva
            try:
                conn = psycopg2.connect(DATABASE_URL)
                emocion_inferida = inferir_emocion_no_dicha(session["emociones_detectadas"], conn)
                conn.close()
            except Exception as e:
                print("‚ùå Error al conectar a la base para inferencia en interacci√≥n 5:", e)
                emocion_inferida = None
        
            # Guardar inferencia en la sesi√≥n
            session["emocion_inferida_5"] = emocion_inferida
        
            if emocion_inferida:
                respuesta = (
                    f"{resumen} Adem√°s, ¬ødir√≠as que tambi√©n podr√≠as estar atravesando cierta {emocion_inferida}? "
                    f"Lo pregunto porque suele aparecer en casos similares."
                )
            else:
                respuesta = f"{resumen} ¬øte interesar√≠a consultarlo con el Lic. Daniel O. Bustamante?"
        
            registrar_respuesta_openai(interaccion_id, respuesta)
            return {"respuesta": respuesta}

        if contador == 6 and session.get("emocion_inferida_5"):
            emocion = session["emocion_inferida_5"]
            if emocion in mensaje_usuario or "s√≠" in mensaje_usuario or "me pasa" in mensaje_usuario:
                if emocion not in session["emociones_detectadas"]:
                    session["emociones_detectadas"].append(emocion)
                    registrar_emocion(emocion, f"confirmaci√≥n de inferencia (interacci√≥n 6)", user_id)
        
                return {
                    "respuesta": (
                        f"Gracias por confirmarlo. ¬øQuer√©s contarme un poco m√°s sobre c√≥mo se manifiesta esa {emocion}?"
                    )
                }

        
        if contador == 9:
            mensajes_previos = session["mensajes"][-3:]
            emociones_nuevas = []
        
            for mensaje in mensajes_previos:
                nuevas = detectar_emociones_negativas(mensaje) or []
                for emocion in nuevas:
                    emocion = emocion.lower().strip()
                    if emocion not in session["emociones_detectadas"]:
                        emociones_nuevas.append(emocion)
        
            # Validar si hay emociones previas, y si no, intentar detectar de nuevo
            if not session["emociones_detectadas"] and emociones_nuevas:
                session["emociones_detectadas"].extend(emociones_nuevas)
            else:
                session["emociones_detectadas"] = list(set(session["emociones_detectadas"] + emociones_nuevas))
        
            # Registrar emociones nuevas no presentes en BD para esta interacci√≥n
            emociones_registradas_bd = obtener_emociones_ya_registradas(user_id, contador)
            for emocion in emociones_nuevas:
                if emocion not in emociones_registradas_bd:
                    registrar_emocion(emocion, f"interacci√≥n {contador}", user_id)
        
            # üß† Estado emocional global sintetizado por cerebro_simulado
            estado_global = clasificar_estado_mental(session["mensajes"])
            if estado_global != "estado emocional no definido":
                print(f"üß† Estado global sintetizado: {estado_global}")
                registrar_inferencia(user_id, contador, "estado_mental", estado_global)
        
            # üßæ Generar resumen cl√≠nico con todas las emociones acumuladas
            resumen = generar_resumen_clinico_y_estado(session, contador)
        
            # üß† Inferencia emocional adicional (segunda intuici√≥n cl√≠nica)
            try:
                conn = psycopg2.connect(DATABASE_URL)
                emocion_inferida = inferir_emocion_no_dicha(session["emociones_detectadas"], conn)
                conn.close()
            except Exception as e:
                print("‚ùå Error al conectar a la base para inferencia en interacci√≥n 9:", e)
                emocion_inferida = None
        
            session["emocion_inferida_9"] = emocion_inferida
        
            if emocion_inferida:
                respuesta = (
                    f"{resumen} Adem√°s, ¬øte ha pasado sentir tambi√©n {emocion_inferida}? "
                    f"Lo menciono porque es un patr√≥n que suele aparecer cuando coexisten estos s√≠ntomas."
                )
            else:
                respuesta = (
                    f"{resumen} Adem√°s, se identific√≥ un posible estado emocional global: {estado_global}. "
                    f"¬øte interesar√≠a consultarlo con el Lic. Daniel O. Bustamante?"
                )
        
            registrar_respuesta_openai(interaccion_id, respuesta)
            return {"respuesta": respuesta}

        if contador >= 11:
            print(f"üîí Interacci√≥n {contador}: se activ√≥ el modo de cierre definitivo. No se realizar√° nuevo an√°lisis cl√≠nico.")
        
            # üß† Detecci√≥n de intenci√≥n de cierre con cerebro_simulado
            cierre_detectado = inferir_intencion_usuario(session["mensajes"])
            print(f"üß† Intenci√≥n inferida por el cerebro simulado: {cierre_detectado}")
        
            if cierre_detectado == "intenci√≥n de cierre":
                registrar_inferencia(user_id, contador, "intencion_de_cierre", cierre_detectado)
                return {
                    "respuesta": (
                        "Gracias por tu mensaje. Me alegra haber podido brindarte orientaci√≥n en este espacio. "
                        "Si en alg√∫n momento dese√°s avanzar con una consulta, pod√©s escribirle al Lic. Bustamante. "
                        + obtener_mensaje_contacto()
                    )
                }
        
            # Si no hay cierre expl√≠cito, usar cierre profesional rotativo seg√∫n cantidad de emociones
            cantidad_emociones = len(set(session.get("emociones_detectadas", [])))
        
            if cantidad_emociones >= 2:
                respuestas_cierre_definitivo = [
                    "Gracias por compartir lo que est√°s sintiendo. Ya hemos recorrido juntos un an√°lisis significativo. Para seguir avanzando, te recomiendo contactar al Lic. Bustamante. " + obtener_mensaje_contacto(),
                    "Valoro la confianza con la que expresaste tus emociones. Este espacio ya cumpli√≥ su funci√≥n de orientaci√≥n. Para una atenci√≥n personalizada, pod√©s continuar con el Lic. Bustamante. " + obtener_mensaje_contacto(),
                    "Hemos llegado al punto en que una intervenci√≥n profesional directa ser√≠a lo m√°s adecuado. El Lic. Bustamante est√° disponible para ayudarte. " + obtener_mensaje_contacto(),
                    "Agradezco tu apertura durante esta conversaci√≥n. Para seguir explorando lo que est√°s atravesando en profundidad, lo ideal es hacerlo con el Lic. Bustamante en un entorno cl√≠nico. " + obtener_mensaje_contacto(),
                    "Lo que compartiste ha sido importante. A partir de aqu√≠, solo un espacio terap√©utico puede brindarte el acompa√±amiento que necesit√°s. " + obtener_mensaje_contacto()
                ]
            else:
                respuestas_cierre_definitivo = [
                    "Este espacio ha llegado a su l√≠mite. Si dese√°s avanzar con una consulta, pod√©s escribirle al Lic. Bustamante. " + obtener_mensaje_contacto(),
                    "Para continuar, es necesario un espacio cl√≠nico adecuado. Pod√©s contactar al Lic. Bustamante si quer√©s seguir con esta consulta. " + obtener_mensaje_contacto(),
                    "Este asistente ha cumplido su funci√≥n orientativa. Para una atenci√≥n m√°s profunda, pod√©s escribirle al Lic. Bustamante. " + obtener_mensaje_contacto()
                ]
        
            return {"respuesta": random.choice(respuestas_cierre_definitivo)}

        
        # üîπ Consultas sobre obras sociales, prepagas o asistencia psicol√≥gica
        preguntas_cobertura = [
            r"(atiende[n|s]?|trabaja[n|s]?|acepta[n|s]?|tom[a|√°s]|toma[n]?|atiendo)\s+(por|con)?\s*(osde|swiss medical|galeno|prepaga|obra social|cobertura m√©dica|asistencia psicol√≥gica)",
            r"(osde|swiss medical|galeno|prepaga|obra social|cobertura m√©dica|asistencia psicol√≥gica)\s+.*(cubren|incluye|incluyen|puedo usar|sirve|vale|acepta|aceptan|trabaja|trabajan|atiende|atienden)",
            r"(puedo|quiero|necesito).*(usar|utilizar).*(osde|swiss medical|galeno|prepaga|obra social)",
            r"(cubren|cubre|acepta|acept√°s|aceptan|trabaja|trabaj√°s|trabajan|atiende|atend√©s|atienden).*?(osde|swiss medical|galeno|prepaga|obra social)"
        ]
        
        for patron in preguntas_cobertura:
            if re.search(patron, mensaje_usuario):
                return {
                    "respuesta": (
                        "El Lic. Daniel O. Bustamante no trabaja con obras sociales ni prepagas. "
                        "Atiende √∫nicamente de manera particular. Si quer√©s coordinar una sesi√≥n, pod√©s escribirle al WhatsApp +54 911 3310-1186."
                    )
                }
        
        # üîπ Consultas sobre precios, honorarios o valor de la sesi√≥n
        if any(palabra in mensaje_usuario for palabra in [
            "precio", "cu√°nto sale", "cu√°nto cuesta", "valor", "honorario", "cobra", "cobr√°s",
            "tarifa", "cu√°nto cobra", "cuanto cobra", "cu√°nto es", "sale la consulta", "vale la consulta",
            "cu√°nto cobran", "cu√°nto hay que pagar", "cu√°nto cuesta la consulta", "cu√°nto tengo que pagar"
        ]):
            return {
                "respuesta": (
                    "El valor de la sesi√≥n puede depender del tipo de consulta. "
                    "Para conocer el costo exacto, te recomiendo escribirle directamente al Lic. Bustamante al WhatsApp +54 911 3310-1186."
                )
            }


        # üîπ Consultas sobre los servicios psicol√≥gicos que ofrece
        consultas_servicios = [
            "qu√© servicios ofrece", "qu√© servicios brinda", "qu√© trata", "con qu√© trabaja", "en qu√© temas trabaja",
            "qu√© tipo de terapias hace", "qu√© tipo de terapia ofrece", "qu√© temas aborda", "qu√© puede tratar",
            "cu√°les son sus especialidades", "qu√© tipo de atenci√≥n brinda", "qu√© problemas trata", "qu√© √°reas trabaja",
            "temas que trata", "qu√© trata bustamante", "qu√© hace el licenciado", "qu√© atiende", "motivos de consulta",
            "problemas que atiende", "en qu√© puede ayudarme"
        ]
        
        if any(frase in mensaje_usuario for frase in consultas_servicios):
            return {
                "respuesta": (
                    "El Lic. Daniel O. Bustamante brinda atenci√≥n psicol√≥gica exclusivamente online, a trav√©s de videoconsultas.\n\n"
                    "Entre los principales motivos de consulta que aborda se encuentran:\n"
                    "- Psicoterapia individual para adultos (modalidad online)\n"
                    "- Tratamiento de crisis emocionales\n"
                    "- Abordaje de ansiedad, estr√©s y ataques de p√°nico\n"
                    "- Procesos de duelo y cambios vitales\n"
                    "- Estados an√≠micos depresivos\n"
                    "- Problemas de autoestima y motivaci√≥n\n"
                    "- Dificultades vinculares y emocionales\n"
                    "- Terapia de pareja online\n\n"
                    + obtener_mensaje_contacto()
                )
            }

        # üîπ Consultas sobre duraci√≥n o frecuencia de las sesiones
        consultas_duracion_frecuencia = [
            "cu√°nto dura", "cuanto dura", "duraci√≥n de la sesi√≥n", "dura la sesi√≥n", "cu√°nto tiempo", "cu√°nto tiempo duran", 
            "cada cu√°nto", "frecuencia", "con qu√© frecuencia", "cu√°ntas veces", "cu√°ntas sesiones", "cada cu√°nto tiempo",
            "cu√°nto duran las sesiones", "duraci√≥n sesi√≥n", "sesi√≥n dura"
        ]
        
        if any(frase in mensaje_usuario for frase in consultas_duracion_frecuencia):
            return {
                "respuesta": (
                    "Las sesiones con el Lic. Daniel O. Bustamante tienen una duraci√≥n aproximada de 50 minutos y se realizan por videoconsulta.\n\n"
                    "La frecuencia puede variar seg√∫n cada caso, pero generalmente se recomienda un encuentro semanal para favorecer el proceso terap√©utico.\n\n"
                    + obtener_mensaje_contacto()
                )
            }
            
        # üîπ Consultas sobre formas de pago, precios o modalidad de pago
        consultas_pago = [
            "c√≥mo se paga", "formas de pago", "medios de pago", "se puede pagar", "puedo pagar", "pago", "se abona", 
            "c√≥mo abono", "c√≥mo es el pago", "modalidad de pago", "se paga por sesi√≥n", "pagar con", "c√≥mo pagar"
        ]
        
        if any(frase in mensaje_usuario for frase in consultas_pago):
            return {
                "respuesta": (
                    "El Lic. Daniel O. Bustamante trabaja con modalidad de pago particular.\n\n"
                    "Para coordinar una sesi√≥n y consultar los medios de pago disponibles, "
                    + obtener_mensaje_contacto()
                )
            }
        
        
        # üîπ Generar respuesta con OpenAI si no es la interacci√≥n 5, 9 o 10+
        prompt = (
            f"Mensaje recibido del usuario: '{mensaje_usuario}'.\n\n"
            "Redact√° una respuesta breve, profesional y cl√≠nica como si fueras el asistente virtual del Lic. Daniel O. Bustamante, psic√≥logo.\n\n"
            "Estilo y directrices obligatorias:\n"
            "- Manten√© un tono cl√≠nico, sobrio, profesional y respetuoso.\n"
            "- Comenz√° la respuesta con un saludo breve como 'Hola, ¬øqu√© tal?'.\n"
            "- Si se detecta malestar emocional, formul√° una observaci√≥n objetiva con expresiones como: 'pareciera tratarse de...', 'podr√≠a vincularse a...', 'refiere a...' o 'se observa...'.\n"
            "- Evit√° cualquier frase emocional simulada (ej: 'te entiendo', 'est√°s en buenas manos', 'no est√°s solo/a', 'tranquilo/a', etc.).\n"
            "- No uses frases motivacionales ni lenguaje coloquial (evit√°: 'todo va a estar bien', 'cont√° conmigo', etc.).\n"
            "- No uses lenguaje institucional como 'nuestro equipo', 'desde nuestro espacio', 'trabajamos en conjunto', etc.\n"
            "- No brindes datos de contacto, precios, horarios, enlaces ni informaci√≥n administrativa.\n"
            "- No recomiendes consultar con el Lic. Bustamante ni uses expresiones como 'consultar con un profesional', 'buscar ayuda especializada' u otras sugerencias impl√≠citas.\n"
            "- No formules preguntas como ‚Äú¬øDese√°s que te facilite informaci√≥n sobre agendar?‚Äù ni menciones WhatsApp.\n"
            "- No uses 'Estimado/a', ni encabezados de carta o email.\n"
            "- Solamente si el mensaje es claramente cl√≠nico, gener√° una respuesta anal√≠tica breve y profesional.\n"
            "- Si el mensaje no tiene contenido emocional o cl√≠nico relevante, devolv√© una frase neutra como: 'Gracias por tu mensaje. ¬øHay algo puntual que te gustar√≠a compartir o consultar en este espacio?'\n\n"
            "IMPORTANTE:\n"
            "- En las interacciones 1 a 4, nunca sugieras contacto ni derivaci√≥n, salvo que el usuario lo pida expl√≠citamente.\n"
            "- Solo en las interacciones 5, 9 o a partir de la 10, pod√©s aceptar que se mencione el contacto si fue solicitado.\n"
        )

        # Obtener respuesta de OpenAI
        respuesta_original = generar_respuesta_con_openai(prompt, contador, user_id, mensaje_usuario, mensaje_original)

        # üîí Filtro contra menci√≥n indebida al Lic. Bustamante fuera de interacciones permitidas
        if contador not in [5, 9] and contador < 10 and not es_consulta_contacto(mensaje_usuario, user_id, mensaje_original):
            if "bustamante" in respuesta_original.lower() or "+54 911 3310-1186" in respuesta_original:
                # Eliminar cualquier frase que mencione al Lic. Bustamante o su n√∫mero
                respuesta_filtrada = re.sub(
                    r"(el Lic\.? Bustamante.*?[\.\!\?])",
                    "",
                    respuesta_original,
                    flags=re.IGNORECASE
                )
                motivo = "Menci√≥n indebida a contacto fuera de interacciones 5, 9 o 10+"
                registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_filtrada.strip(), motivo)
                respuesta_ai = respuesta_filtrada.strip()
            else:
                respuesta_ai = respuesta_original
        else:
            respuesta_ai = respuesta_original

        # üõë Filtro para derivaciones impl√≠citas indebidas
        frases_implicitas_derivacion = [
            "podr√≠as trabajarlo con", "te sugiero considerarlo en una consulta",
            "evaluarlo con un profesional", "ser√≠a conveniente que lo converses",
            "hablarlo en un espacio terap√©utico", "apoyo profesional", 
            "ayuda especializada", "espacio terap√©utico", 
            "alguien capacitado", "profesional de la salud mental"
        ]
        
        if contador not in [5, 9] and contador < 10 and not es_consulta_contacto(mensaje_usuario, user_id, mensaje_original):
            for frase in frases_implicitas_derivacion:
                if frase in respuesta_original.lower():
                    motivo = "Derivaci√≥n impl√≠cita fuera de interacci√≥n permitida"
                    respuesta_ai = (
                        "Gracias por tu mensaje. Si quer√©s, pod√©s contarme un poco m√°s sobre lo que est√°s sintiendo "
                        "para poder continuar con el an√°lisis cl√≠nico correspondiente."
                    )
                    registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_ai, motivo)
                    break
                return {"respuesta": respuesta_ai}
        
        # üîê Seguridad textual: verificar si la respuesta de OpenAI contiene elementos peligrosos
        if contiene_elementos_peligrosos(respuesta_original):
            respuesta_ai = (
                "Por razones de seguridad, la respuesta generada fue descartada por contener elementos t√©cnicos no permitidos. "
                "Pod√©s intentar formular tu consulta de otra manera o escribir directamente al WhatsApp del Lic. Bustamante: +54 911 3310-1186."
            )
            registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_ai, "Respuesta descartada por contener elementos peligrosos")
            return {"respuesta": respuesta_ai}

        
        # Validaci√≥n previa
        if not respuesta_original:
            respuesta_ai = (
                "Lo siento, hubo un inconveniente al generar una respuesta autom√°tica. Pod√©s escribirle al Lic. Bustamante al WhatsApp +54 911 3310-1186."
            )
            registrar_auditoria_respuesta(user_id, "Error al generar respuesta", respuesta_ai, "Error: OpenAI devolvi√≥ respuesta vac√≠a")
            return {"respuesta": respuesta_ai}
        
        respuesta_ai = respuesta_original  # Copia editable
        motivo = None

        # üîç Filtro para lenguaje institucional
        palabras_prohibidas = ["nosotros", "nuestro equipo", "nuestra instituci√≥n", "desde nuestra", "trabajamos en conjunto"]
        if any(palabra in respuesta_ai.lower() for palabra in palabras_prohibidas):
            respuesta_ai = (
                "Gracias por tu consulta. El Lic. Daniel O. Bustamante estar√° encantado de ayudarte. "
                "Pod√©s escribirle directamente al WhatsApp +54 911 3310-1186 para obtener m√°s informaci√≥n."
            )

        # üîç Filtro para lenguaje emp√°tico simulado o gen√©rico prohibido
        frases_empaticas_simuladas = [
            "estoy aqu√≠ para ayudarte", "estoy aqu√≠ para ayudarle", "te puedo ayudar", 
            "estamos para ayudarte", "cuente conmigo", "puedo ayudarte", 
            "tranquilo", "no est√°s solo", "est√°s en buenas manos", 
            "todo va a estar bien", "puede contar conmigo"
        ]
        if any(frase in respuesta_ai.lower() for frase in frases_empaticas_simuladas):
            respuesta_ai = (
                "Gracias por tu mensaje. Si quer√©s, pod√©s contarme un poco m√°s sobre lo que est√°s atravesando "
                "para poder continuar con el an√°lisis cl√≠nico correspondiente."
            )
            motivo = "Frase emp√°tica simulada detectada y reemplazada"

        
        # üîç Filtro para desv√≠os tem√°ticos (por si OpenAI habla de finanzas o cosas raras)
        temas_prohibidos = ["finanzas", "inversiones", "educaci√≥n financiera", "consultor√≠a financiera", "legal", "t√©cnico"]
        if any(tema in respuesta_ai.lower() for tema in temas_prohibidos):
            respuesta_ai = (
                "El Lic. Daniel O. Bustamante es psic√≥logo cl√≠nico. Si quer√©s saber m√°s sobre los servicios que ofrece, "
                + obtener_mensaje_contacto() +
                " y te brindar√° toda la informaci√≥n necesaria."
            )

        # üîç Filtro para eliminar encabezados como ‚ÄúEstimado/a usuario/a‚Äù
        if respuesta_original.lower().startswith("estimado") or "estimado/a" in respuesta_original.lower():
            respuesta_original = re.sub(r"(?i)^estimado/a\s+usuario/a,?\s*", "", respuesta_original).strip()

        
        # üîç Reemplazo de marcador si qued√≥ en la respuesta
        respuesta_ai = respuesta_ai.replace("[Incluir n√∫mero de contacto]", "+54 911 3310-1186")

        # üõ°Ô∏è Filtrado de precios por si OpenAI menciona alg√∫n valor num√©rico
        if any(palabra in respuesta_ai.lower() for palabra in ["$", "usd", "euros", "‚Ç¨", "d√≥lares", "pesos", "cuesta", "sale", "vale", "precio", "tarifa", "honorario", "paga", "cobra", "cobro"]):
            respuesta_ai = (
                "Sobre los valores de la consulta, te sugiero contactar directamente al Lic. Daniel O. Bustamante. "
                + obtener_mensaje_contacto() +
                " para obtener esa informaci√≥n de manera personalizada."
            )
            # üßæ Auditor√≠a: log si OpenAI intent√≥ responder con precios
            print("‚ö†Ô∏è Se intercept√≥ una respuesta con posible contenido de precios y fue reemplazada para evitar brindar esa informaci√≥n.")

        # ‚ùå Interceptar frases ambiguas que sugieran contacto antes de la interacci√≥n 5
        if contador <= 4:
            frases_implicitas = [
                "si lo desea puedo brindarle m√°s informaci√≥n",
                "si desea m√°s informaci√≥n",
                "puedo brindarle m√°s detalles si lo necesita",
                "si quiere puedo contarle m√°s",
                "estoy aqu√≠ para ayudarle",
                "podr√≠a ayudarle si lo desea",
                "si desea saber m√°s"
            ]
            if any(f in respuesta_ai.lower() for f in frases_implicitas):
                respuesta_ai = (
                    "Gracias por tu mensaje. En este espacio se brinda orientaci√≥n cl√≠nica general. "
                    "¬øQuer√©s contarme un poco m√°s sobre lo que est√°s sintiendo para poder ayudarte mejor?"
                )
                motivo = "Frase ambigua de sugerencia de contacto detectada en interacci√≥n temprana"


        # Detectar modificaciones y registrar auditor√≠a
        if respuesta_original != respuesta_ai:
            motivo = "Respuesta modificada por contener lenguaje institucional, tem√°ticas no permitidas o precios"
            registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_ai, motivo)
        else:
            registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_ai)

        # Usar el ID de interacci√≥n previamente registrado para guardar la respuesta
        registrar_respuesta_openai(interaccion_id, respuesta_ai)

        # ‚ùå Filtrado final de menciones indebidas al Lic. Bustamante antes de interacci√≥n 5
        if "bustamante" in respuesta_ai.lower() and contador not in [5, 9] and contador < 10 and not es_consulta_contacto(mensaje_usuario, user_id, mensaje_original):
            respuesta_filtrada = re.sub(r"(?i)con (el )?Lic(\.|enciado)? Daniel O\.? Bustamante.*?(\.|\n|$)", "", respuesta_ai)
            motivo = "Se elimin√≥ menci√≥n indebida al Lic. Bustamante antes de interacci√≥n permitida"
            registrar_auditoria_respuesta(user_id, respuesta_original, respuesta_filtrada, motivo)
            return {"respuesta": respuesta_filtrada}
        
        return {"respuesta": respuesta_ai}

    except Exception as e:
        print(f"‚ùå Error inesperado en el endpoint /asistente: {e}")
        return {
            "respuesta": (
                "Ocurri√≥ un error al procesar tu solicitud. Pod√©s intentarlo nuevamente m√°s tarde "
                "o escribirle al Lic. Bustamante por WhatsApp: +54 911 3310-1186."
            )
        }
