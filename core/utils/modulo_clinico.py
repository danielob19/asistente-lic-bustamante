import openai
import re
import time
import unicodedata
import string
from typing import Dict, Any
from datetime import datetime
from datetime import datetime, timedelta  # ‚Üê a√±adimos timedelta para c√°lculos de reingreso


from core.utils.clinico_contexto import hay_contexto_clinico_anterior
from core.utils_contacto import obtener_mensaje_contacto
from core.funciones_asistente import detectar_emociones_negativas
from core.utils.generador_openai import generar_respuesta_con_openai
from core.constantes import CLINICO, CLINICO_CONTINUACION


from core.db.registro import (
    registrar_respuesta_openai,
    registrar_auditoria_respuesta,
    registrar_interaccion,
    registrar_emocion,
    registrar_emocion_clinica,
    registrar_historial_clinico,   # <- importante
)


from core.db.registro import registrar_historial_clinico

from core.db.sintomas import (
    registrar_sintoma,
    obtener_sintomas_existentes
)

from core.db.consulta import (
    obtener_emociones_ya_registradas,
    obtener_historial_clinico_usuario
)

from core.db.conexion import ejecutar_consulta  # Eliminado user_sessions

# Producci√≥n: considerar reingreso a partir de 60 segundos
REINGRESO_SEGUNDOS = 60

def armar_prompt_openai(historial_emociones, nuevas_emociones, ultima_interaccion, nombre_usuario=None):
    resumen = ""
    if historial_emociones:
        resumen += (
            f"El usuario {nombre_usuario or ''} ha consultado previamente por: "
            f"{', '.join(historial_emociones)}.\n"
        )
    if nuevas_emociones:
        resumen += (
            f"En esta interacci√≥n expresa: {', '.join(nuevas_emociones)}.\n"
        )
    if ultima_interaccion:
        resumen += f"√öltimo comentario relevante del usuario: '{ultima_interaccion}'.\n"

    prompt = (
        "Sos un asistente cl√≠nico digital que acompa√±a a personas en situaciones emocionales delicadas. "
        "Analiz√° el siguiente contexto emocional, detect√° patrones relevantes y suger√≠ con empat√≠a posibles l√≠neas de abordaje cl√≠nico, "
        "sin emitir diagn√≥sticos tajantes ni frases gen√©ricas.\n\n"
        f"{resumen}\n"
        "1. ¬øQu√© emociones/s√≠ntomas son predominantes en este usuario?\n"
        "2. ¬øCu√°l podr√≠a ser el cuadro o estado an√≠mico principal? (Describilo con cautela, nunca de forma definitiva)\n"
        "3. Suger√≠, de forma amable y profesional, si corresponde derivar al Lic. Daniel O. Bustamante, sin forzar la consulta.\n"
        "4. Suger√≠ en una l√≠nea, de modo orientativo y no definitivo, qu√© cuadro cl√≠nico podr√≠a estar predominando seg√∫n la informaci√≥n, usando lenguaje comprensible para el usuario.\n"
        "Por favor, devolv√© la respuesta en el siguiente formato JSON:\n"
        "{'emociones_predominantes': [], 'cuadro_clinico': '', 'mensaje_usuario': ''}"
    )
    return prompt




def armar_respuesta_usuario(respuesta_ia_json, emociones_actuales, nombre_usuario=None):
    texto_intro = ""
    if emociones_actuales:
        texto_intro = (
            f"Gracias por compartir lo que sent√≠s. Hasta ahora mencionaste: {', '.join(emociones_actuales)}.\n"
        )
    mensaje_usuario = respuesta_ia_json.get("mensaje_usuario", "").strip()
    recomendacion = (
        "\nRecord√° que este espacio no reemplaza la consulta con un profesional. "
        "Si lo dese√°s, pod√©s escribirle al Lic. Daniel O. Bustamante para un acompa√±amiento m√°s personalizado."
    )
    respuesta_final = f"{texto_intro}{mensaje_usuario}{recomendacion}"
    return respuesta_final




def normalizar_texto(texto: str) -> str:
    if not texto or not isinstance(texto, str):
        texto = ""
    texto = texto.lower().strip()
    texto = unicodedata.normalize("NFKD", texto).encode("ascii", "ignore").decode("utf-8")
    texto = texto.translate(str.maketrans("", "", string.punctuation))
    return texto


def recuperar_historial_clinico(user_id, limite=5):
    query = """
    SELECT fecha, emociones, sintomas, tema, respuesta_openai, sugerencia, fase_evaluacion
    FROM historial_clinico_usuario
    WHERE user_id = %s AND eliminado = FALSE
    ORDER BY fecha DESC
    LIMIT %s
    """
    try:
        resultados = ejecutar_consulta(query, (user_id, limite))
        return resultados or []
    except Exception as e:
        print(f"üî¥ Error al recuperar historial cl√≠nico: {e}")
        return []

def construir_resumen_historial(historial):
    """
    Construye un resumen seguro del historial cl√≠nico evitando KeyError.
    Soporta listas, tuplas y diccionarios.
    """
    temas = []
    for h in historial:
        # Si es lista o tupla y tiene al menos 4 elementos
        if isinstance(h, (list, tuple)) and len(h) > 3:
            if h[3]:
                temas.append(h[3])
        # Si es diccionario y contiene la clave 'tema'
        elif isinstance(h, dict) and "tema" in h:
            if h["tema"]:
                temas.append(h["tema"])

    return temas


# Diccionario de emociones cl√≠nicas observables
emociones_clinicas = {
    "angustia": ["angustiado", "angustia"],
    "ansiedad": ["ansioso", "ansiedad", "nervioso", "preocupado"],
    "estr√©s": ["estresado", "estr√©s"],
    "tristeza": ["triste", "deprimido", "bajoneado", "vac√≠o"],
}

def detectar_emocion(texto: str) -> str | None:
    texto = texto.lower()
    for emocion, variantes in emociones_clinicas.items():
        for variante in variantes:
            if re.search(rf"\b{re.escape(variante)}\b", texto):
                return emocion
    return None







def procesar_clinico(input_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Flujo cl√≠nico alineado a directiva:
      - OpenAI detecta emociones y cuadro probable en cada mensaje cl√≠nico.
      - Registrar novedades (emociones nuevas / cuadro) en public.historial_clinico_usuario.
      - Disparador (<10): si hay ‚â•2 coincidencias (sesi√≥n + historial + global) hacia el mismo cuadro ‚Üí responder con
        resumen breve + 'Cuadro cl√≠nico probable', y no repetir en la sesi√≥n.
      - Reingreso producci√≥n: recordar emociones/cuadro previos si pasaron ‚â•60s y preguntar por emociones nuevas.
    """
    import json, re
    from datetime import datetime
    # Imports internos para evitar cambiar otros bloques
    from core.db.consulta import (
        obtener_historial_usuario,
        obtener_ultimo_registro_usuario,
        estadistica_global_emocion_a_cuadro,
    )
    from core.db.registro import registrar_novedad_openai
    from core.utils.generador_openai import generar_respuesta_con_openai

    # --- Extraer inputs ---
    mensaje_original = input_data["mensaje_original"]
    mensaje_usuario = input_data["mensaje_usuario"]
    user_id = input_data["user_id"]
    session = input_data["session"]
    contador = int(input_data["contador"])

    # --- Utilidades locales ---
    def _limpiar_lista_str(xs):
        if not xs:
            return []
        return [re.sub(r"\s+", " ", x.strip().lower()) for x in xs if isinstance(x, str) and x.strip()]

    def _ask_openai_emociones_y_cuadro(texto_usuario: str):
        prompt = (
            "Analiz√° el siguiente mensaje cl√≠nico de un usuario. "
            "Respond√© en JSON con dos claves: "
            "{\"emociones\": [..], \"cuadro_probable\": \"...\"}. "
            "Reglas: solo emociones negativas/relevantes; si no hay, emociones=[] y cuadro_probable=\"\".\n\n"
            f"TEXTO: {texto_usuario}"
        )
        out = generar_respuesta_con_openai(prompt) or '{"emociones": [], "cuadro_probable": ""}'
        try:
            data = json.loads(out)
            emociones = _limpiar_lista_str(data.get("emociones", []))
            cuadro = (data.get("cuadro_probable") or "").strip().lower()
            return emociones, cuadro
        except Exception:
            # fallback robusto: separar por comas / saltos
            emos = [x.strip() for x in re.split(r"[,\n]", out) if x.strip()]
            return _limpiar_lista_str(emos), ""

    def _coincidencias_sesion_historial_global(user_id: str, emociones_sesion, cuadro_openai: str):
        """
        Cuenta coincidencias hacia el mismo cuadro combinando:
          - emociones de la sesi√≥n (nuevas)
          - emociones ya registradas en el historial del usuario
          - estad√≠stica global emoci√≥n‚Üícuadro (solo memoria; no crea etiquetas)
        Devuelve (votos, detalles, cuadro_objetivo).
        """
        emociones_sesion = set(_limpiar_lista_str(emociones_sesion))
        # Historial propio
        hist = obtener_historial_usuario(user_id, limite=200)
        emos_hist = set()
        for r in hist:
            # r = (id, user_id, fecha, emociones, nuevas_emociones_detectadas, cuadro_clinico_probable, interaccion_id)
            for e in (r[3] or []):
                emos_hist.add((e or "").strip().lower())

        # Estad√≠stica global: emoci√≥n -> {cuadros}
        glob = estadistica_global_emocion_a_cuadro() or []
        map_emo_to_cuadro = {}
        for emocion, cuadro, c in glob:
            if not emocion or not cuadro:
                continue
            map_emo_to_cuadro.setdefault(emocion, set()).add(cuadro)

        objetivo = (cuadro_openai or "").strip().lower()
        votos = 0
        detalles = {"sesion": [], "historial": []}

        # Sesi√≥n
        for e in emociones_sesion:
            if objetivo and e in map_emo_to_cuadro and objetivo in map_emo_to_cuadro[e]:
                votos += 1
                detalles["sesion"].append(e)

        # Historial del usuario
        for e in emos_hist:
            if objetivo and e in map_emo_to_cuadro and objetivo in map_emo_to_cuadro[e]:
                votos += 1
                detalles["historial"].append(e)

        return votos, detalles, objetivo

    # --- Estado de sesi√≥n ---
    ahora = datetime.now()
    session.setdefault("emociones_detectadas", [])
    session.setdefault("disparo_notificado", False)
    session.setdefault("ultima_fecha", ahora.isoformat())

    # --- 1) Detectar con OpenAI ---
    emociones_openai, cuadro_openai = _ask_openai_emociones_y_cuadro(mensaje_usuario)

    # --- 2) Registrar novedades (memoria persistente √∫nica) ---
    emos_prev = set(_limpiar_lista_str(session.get("emociones_detectadas", [])))
    nuevas_emos = [e for e in emociones_openai if e not in emos_prev]

    if emociones_openai or cuadro_openai:
        registrar_novedad_openai(
            user_id=user_id,
            emociones=emociones_openai,
            nuevas_emociones_detectadas=nuevas_emos,
            cuadro_clinico_probable=cuadro_openai or None,
            interaccion_id=contador,
            fuente="openai",
        )

    # Actualizar sesi√≥n
    session["emociones_detectadas"] = list(emos_prev.union(emociones_openai))
    session["ultima_fecha"] = ahora.isoformat()

        # 3) Disparador por coincidencias (<10 y a√∫n no notificado)
        texto_out = ""
        if contador < 10 and cuadro_openai and not session.get("disparo_notificado", False):
            # Contar coincidencias priorizando el cuadro devuelto por OpenAI
            # (usa la estad√≠stica global de la misma tabla como memoria)
            emociones_union = list(set(_limpiar_lista_str(session.get("emociones_detectadas", [])) + _limpiar_lista_str(emociones_openai)))
            votos, detalles, objetivo = _coincidencias_sesion_historial_global(
                user_id=user_id,
                emociones_sesion=emociones_union,
                cuadro_openai=cuadro_openai
            )
    
            if votos >= 2:
                resumen_breve = ""
                if emociones_openai:
                    resumen_breve += f"En esta interacci√≥n se identifican: {', '.join(emociones_openai)}. "
    
                texto_out = f"{resumen_breve}Cuadro cl√≠nico probable: **{objetivo}**."
    
                # Registrar expl√≠citamente el suceso de disparo (adem√°s del registro previo de novedades)
                registrar_novedad_openai(
                    user_id=user_id,
                    emociones=session.get("emociones_detectadas", []),
                    nuevas_emociones_detectadas=[],
                    cuadro_clinico_probable=objetivo,
                    interaccion_id=contador,
                    fuente="openai_disparo"
                )
    
                # Bandera de sesi√≥n para no repetir el disparo
                session["disparo_notificado"] = True
                session["disparo_cuadro"] = objetivo


        # 4) Recordatorio al reconectar (si vuelve luego de un tiempo y trae contenido cl√≠nico)
        ultimo = obtener_ultimo_registro_usuario(user_id)
        recordatorio = ""
        if ultimo:
            fecha_ult = ultimo[2]
            try:
                if isinstance(fecha_ult, str):
                    # intento parseo b√°sico ISO
                    fecha_ult_dt = datetime.fromisoformat(fecha_ult.replace("Z", ""))
                else:
                    fecha_ult_dt = fecha_ult
    
                delta = ahora - fecha_ult_dt
                seg = int(delta.total_seconds())
    
                if seg >= REINGRESO_SEGUNDOS and (emociones_openai or cuadro_openai):
                    emos_previas = _limpiar_lista_str(ultimo[3] or [])  # emociones
                    cuadro_prev = (ultimo[5] or "").strip().lower()     # cuadro
    
                    if emos_previas or cuadro_prev:
                        prev = ""
                        if emos_previas:
                            prev += f"Previo se registraron: {', '.join(emos_previas)}. "
                        if cuadro_prev:
                            prev += f"Se hab√≠a estimado como probable: {cuadro_prev}. "
    
                        # Formato amigable del tiempo transcurrido
                        if seg < 3600:
                            mins = max(1, seg // 60)
                            trans = f"~{mins}m"
                        elif seg < 86400:
                            horas = seg // 3600
                            trans = f"~{horas}h"
                        else:
                            dias = seg // 86400
                            trans = f"~{dias}d"
    
                        recordatorio = (
                            f"{prev}Pasaron {trans} desde la √∫ltima conversaci√≥n. "
                            f"¬øAparecieron emociones nuevas?"
                        )
            except Exception:
                pass


    # --- 5) Respuesta base si no hubo disparador ---
    if not texto_out:
        base = []
        if emociones_openai:
            base.append(f"Se observan: {', '.join(emociones_openai)}.")
        if cuadro_openai:
            base.append(f"Cuadro cl√≠nico probable: {cuadro_openai}.")
        if not base:
            base.append("No aparecen elementos cl√≠nicos relevantes en este mensaje.")
        texto_out = " ".join(base)

    if recordatorio:
        texto_out = f"{texto_out}\n\n{recordatorio}"

    return {"respuesta": texto_out, "session": session}








# ==============================================================
# üìå Obtener todas las emociones hist√≥ricas de un usuario
# ==============================================================
from core.db.conexion import ejecutar_consulta
from sqlalchemy import text  # si quieres seguir usando SQL parametrizado

def obtener_emociones_usuario(user_id):
    """
    Devuelve una lista de emociones hist√≥ricas para el usuario desde la DB.
    """
    try:
        query = """
            SELECT emocion
            FROM emociones_detectadas
            WHERE user_id = %s
        """
        resultados = ejecutar_consulta(query, (user_id,))
        return [row["emocion"] for row in resultados] if resultados else []
    except Exception as e:
        print(f"‚ö†Ô∏è Error en obtener_emociones_usuario: {e}")
        return []


# ==============================================================
# üìå Guardar nueva emoci√≥n en DB
# ==============================================================
def guardar_emocion_en_db(user_id, emocion, clasificacion):
    """
    Inserta una emoci√≥n detectada y su clasificaci√≥n en la DB.
    """
    try:
        query = """
            INSERT INTO emociones_detectadas (user_id, emocion, clasificacion, fecha)
            VALUES (%s, %s, %s, NOW())
        """
        ejecutar_consulta(query, (user_id, emocion, clasificacion), commit=True)
        print(f"üíæ Emoci√≥n '{emocion}' registrada para el usuario {user_id}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error al guardar emoci√≥n en DB: {e}")


# ==============================================================
# üìå Clasificar cuadro cl√≠nico probable (puede usarse IA)
# ==============================================================
def clasificar_cuadro_clinico(emocion):
    """
    Clasifica la emoci√≥n detectada en un cuadro cl√≠nico probable.
    """
    clasificacion_map = {
        "ansiedad": "Posible cuadro de ansiedad generalizada",
        "tristeza": "Posible episodio depresivo",
        "miedo": "Posible cuadro de angustia",
        "insomnio": "Posible trastorno del sue√±o",
        "estres": "Posible cuadro de estr√©s cr√≥nico",
        "deprimido": "Posible episodio depresivo mayor",
        "soledad": "Posible aislamiento emocional"
    }
    return clasificacion_map.get(
        emocion.lower(),
        "Patr√≥n emocional que requiere evaluaci√≥n profesional por el Lic. Daniel O. Bustamante"
    )


# ==============================================================
# üìå Determinar malestar predominante
# ==============================================================
def determinar_malestar_predominante(emociones):
    """
    Determina el malestar m√°s frecuente en la lista de emociones.
    """
    from collections import Counter
    if not emociones:
        return None
    conteo = Counter(emociones)
    return conteo.most_common(1)[0][0]



